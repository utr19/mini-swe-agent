{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"The 100 line AI agent that's actually useful <p>In 2024, SWE-bench &amp; SWE-agent helped kickstart the coding agent revolution.</p> <p>We now ask: What if the agent was 100x smaller, and still worked nearly as well?</p> <p><code>mini</code> is for</p> <ul> <li>Researchers who want to benchmark, fine-tune or RL without assumptions, bloat, or surprises</li> <li>Developers who like their tools like their scripts: short, sharp, and readable</li> <li>Engineers who want something trivial to sandbox &amp; to deploy anywhere</li> </ul> <p>Here's some details:</p> <ul> <li>Minimal: Just 100 lines of python (+100 total for env, model, script) \u2014 no fancy dependencies!</li> <li>Powerful: Resolves 65% of GitHub issues in the SWE-bench verified benchmark (leaderboard).</li> <li>Convenient: Comes with UIs that turn this into your daily dev swiss army knife!</li> <li>Deployable: In addition to local envs, you can use docker, podman, singularity, apptainer, and more</li> <li>Cutting edge: Built by the Princeton &amp; Stanford team behind SWE-bench and SWE-agent.</li> </ul> Why use mini-SWE-agent for research? <p>SWE-agent jump-started the development of AI agents in 2024. Back then, we placed a lot of emphasis on tools and special interfaces for the agent. However, one year later, a lot of this is not needed at all to build a useful agent!</p> <p>In fact, mini-SWE-agent:</p> <ul> <li>Does not have any tools other than bash \u2014 it doesn't even use the tool-calling interface of the LMs.   This means that you can run it with literally any model.   When running in sandboxed environments you also don't need to take care of installing a single package \u2014 all it needs is bash.</li> <li>Has a completely linear history \u2014 every step of the agent just appends to the messages and that's it.   So there's no difference between the trajectory and the messages that you pass on to the LM.   Great for debugging &amp; fine-tuning.</li> <li>Executes actions with <code>subprocess.run</code> \u2014 every action is completely independent (as opposed to keeping a stateful shell session running). This makes it trivial to execute the actions in sandboxes (literally just switch out <code>subprocess.run</code> with <code>docker exec</code>) and to scale up effortlessly.   Seriously, this is a big deal, trust me.</li> </ul> <p>This makes it perfect as a baseline system and for a system that puts the language model (rather than the agent scaffold) in the middle of our attention. You can see the result on the SWE-bench (bash only) leaderboard, that evaluates the performance of different LMs with <code>mini</code>.</p> Why use mini-SWE-agent as a tool? <p>Some agents are overfitted research artifacts. Others are UI-heavy frontend monsters.</p> <p><code>mini</code> wants to be a hackable tool, not a black box.</p> <ul> <li>Simple enough to understand at a glance</li> <li>Convenient enough to use in daily workflows</li> <li>Flexible to extend</li> </ul> <p>Unlike other agents (including our own swe-agent), it is radically simpler, because it:</p> <ul> <li>Does not have any tools other than bash \u2014 it doesn't even use the tool-calling interface of the LMs.   Instead of implementing custom tools for every specific thing the agent might want to do, the focus is fully on the LM utilizing the shell to its full potential.   Want it to do something specific like opening a PR?   Just tell the LM to figure it out rather than spending time to implement it in the agent.</li> <li>Executes actions with <code>subprocess.run</code> \u2014 every action is completely independent (as opposed to keeping a stateful shell session running).   This is a big deal for the stability of the agent, trust me.</li> <li>Has a completely linear history \u2014 every step of the agent just appends to the messages that are passed to the LM in the next step and that's it.   This is great for debugging and understanding what the LM is prompted with.</li> </ul> Should I use mini-SWE-agent or swe-agent? <p>You should use <code>mini-swe-agent</code> if</p> <ul> <li>You want a quick command line tool that works locally</li> <li>You want an agent with a very simple control flow</li> <li>You want even faster, simpler &amp; more stable sandboxing &amp; benchmark evaluations</li> <li>You are doing FT or RL and don't want to overfit to a specific agent scaffold</li> </ul> <p>You should use <code>swe-agent</code> if</p> <ul> <li>You need specific tools or want to experiment with different tools</li> <li>You want to experiment with different history processors</li> <li>You want very powerful yaml configuration without touching code</li> </ul> <p>What you get with both</p> <ul> <li>Excellent performance on SWE-Bench</li> <li>A trajectory browser</li> </ul> Simple UI (<code>mini</code>)  Visual UI (<code>mini -v</code>)  Batch inference Trajectory browser Python bindings More in the docs <pre><code>agent = DefaultAgent(\n    LitellmModel(model_name=...),\n    LocalEnvironment(),\n)\nagent.run(\"Write a sudoku game\")</code></pre> <ul> <li>Quick start</li> <li><code>mini</code></li> <li>FAQ</li> <li>Configuration</li> <li>Power up</li> </ul>"},{"location":"#continue-reading","title":"Continue reading:","text":"launch Installation &amp; Quick Start <p>Get started with mini-SWE-agent</p> flash_on Usage: Simple UI <p>Learn to use the <code>mini</code> command</p> visibility Usage: Visual UI <p>Try the visual interface with <code>mini -v</code></p> help FAQ <p>Common questions and answers</p> settings Configuration <p>Setup and customize your agent</p> fitness_center Power up <p>Start hacking the agent!</p>"},{"location":"#new-features","title":"\ud83d\udce3 New features","text":"<p>Please check the github release notes for the latest updates.</p>"},{"location":"#documentation-updates","title":"\ud83d\udce3 Documentation updates","text":"<ul> <li>Jul 27: More notes on local models</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"SECURITY/","title":"Security Policy","text":""},{"location":"SECURITY/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please contact Kilian Lieret (kl5675@princeton.edu), John Yang (johnby@stanford.edu), Carlos E. Jimenez (carlosej@princeton.edu), and Ofir Press (ofirp@princeton.edu).</p>"},{"location":"_footer/","title":"footer","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"contributing/","title":"\u2764\ufe0f Contributing","text":"<p>We happily accept contributions!</p>"},{"location":"contributing/#areas-of-help","title":"Areas of help","text":"<ul> <li>Feedback on the <code>mini</code> and <code>mini -v</code> interfaces at this github issue or in our Slack channel.</li> <li>Documentation, examples, tutorials, etc. In particular, we're looking for<ul> <li>examples of how this library is used in the wild</li> <li>additional examples for the cookbook</li> </ul> </li> <li>Support for more models (anything where <code>litellm</code> doesn't work out of the box)</li> <li>Support for more environments &amp; deployments (e.g., run it as a github action, etc.)</li> <li>Take a look at the issues and look for issues marked <code>good-first-issue</code> or <code>help-wanted</code> (please read the guidelines below first)</li> </ul>"},{"location":"contributing/#design-architecture","title":"Design &amp; Architecture","text":"<ul> <li><code>mini-swe-agent</code> aims to stay minimalistic, hackable, and of high quality code.</li> <li>To extend features, we prefer to add a new version of the one of the four components (see cookbook), rather than making the existing components more complex.</li> <li>Components should be relatively self-contained, but if there are utilities that might be shared, add a <code>utils</code> folder (like this one). But keep it simple!</li> <li>If your component is a bit more specific, add it into an <code>extra</code> folder (like this one)</li> <li>Our target audience is anyone who doesn't shy away from modifying a bit of code (especially a run script) to get what they want.</li> <li>Therefore, not everything needs to be configurable with the config files, but it should be easy to create a run script that makes use of it.</li> <li>Many LMs write very verbose code -- please clean it up! Same goes for the tests. They should still be concise and readable.</li> <li>Please install <code>pre-commit</code> (<code>pip install pre-commit &amp;&amp; pre-commit install</code>) and run it before committing. This will enforce our style guide.</li> </ul>"},{"location":"contributing/#development-setup","title":"Development setup","text":"<p>Make sure to follow the dev setup instructions in quickstart.md.</p> <p>After that you can run <code>pytest</code> with <code>pytest -n auto</code> (this parallelizes the tests across all cores for speedup).</p> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#general","title":"General","text":"<p>Does mini-SWE-agent work on my system?</p> <p>mini-SWE-agent should work on any system that has a bash shell or uses a container runtime to emulate one.</p> Should I use mini-SWE-agent or swe-agent? <p>You should use <code>mini-swe-agent</code> if</p> <ul> <li>You want a quick command line tool that works locally</li> <li>You want an agent with a very simple control flow</li> <li>You want even faster, simpler &amp; more stable sandboxing &amp; benchmark evaluations</li> <li>You are doing FT or RL and don't want to overfit to a specific agent scaffold</li> </ul> <p>You should use <code>swe-agent</code> if</p> <ul> <li>You need specific tools or want to experiment with different tools</li> <li>You want to experiment with different history processors</li> <li>You want very powerful yaml configuration without touching code</li> </ul> <p>What you get with both</p> <ul> <li>Excellent performance on SWE-Bench</li> <li>A trajectory browser</li> </ul> How is <code>mini</code> simpler than <code>swe-agent</code>? <p><code>mini</code> is simpler than <code>swe-agent</code> because it:</p> <ul> <li>Does not have any tools other than bash \u2014 it doesn't even use the tool-calling interface of the LMs.   This means you don't have to install anything in any environment you're running in. <code>bash</code> is all you need.</li> <li>Has a completely linear history \u2014 every step of the agent just appends to the messages and that's it.</li> <li>Executes actions with <code>subprocess.run</code> \u2014 every action is completely independent (as opposed to keeping a stateful shell session running).   This avoids so many issues, trust me.</li> </ul> What are the limitations of mini-SWE-agent? <p>mini-SWE-agent can be extended trivially in various ways, the following assumes the default setup. As reflected in the high SWE-bench scores, none of the following limitations are a problem in practice.</p> <ul> <li>No tools other than bash</li> <li>Actions are parsed from triple-backtick blocks (rather than assuming a function calling/tool calling format)</li> <li>By default, actions are executed as <code>subprocess.run</code>, i.e., every action is independent of the previous ones.   (meaning that the agent cannot change directories or export environment variables; however environment variables   can be set per-action). This avoids so many issues, trust me.</li> </ul> <p>If you want more flexibility with these items, you can use SWE-agent instead.</p> Where is global configuration stored? <p>The global configuration is stored in the <code>.env</code> file in the config directory. The location is printed when you run <code>mini --help</code>.</p> <p>The <code>.env</code> file is a simple key-value file that is read by the <code>dotenv</code> library.</p>"},{"location":"faq/#models","title":"Models","text":"<p>What models do you support?</p> <p>Currently, mini-SWE-agent supports all models that are supported by litellm and we're open to extend the <code>models/</code> directory with more models should <code>litellm</code> not support them.</p> <p>How do I set the API key for a model?</p> <p>The API key can be stored either as an environment variable (note that enviroinment variables are not persistent unless you set them in your <code>~/.bashrc</code> or similar), or as a permanent key in the config file.</p> <p>To temporarily set the API key as an environment variable, you can use the following command:</p> <pre><code>export OPENAI_API_KEY=sk-test123\n</code></pre> <p>To permanently set the API key in the config file, you can use the following command:</p> <pre><code>mini-extra config set OPENAI_API_KEY sk-test123\n</code></pre> <p>Alternatively, you can directly edit the <code>.env</code> file in the config directory (the location is printed when you run <code>mini --help</code>).</p> <p>How can I set the default model?</p> <p>The default model is stored in the config/environment as <code>MSWEA_MODEL_NAME</code>. To permanently change it:</p> <pre><code>mini-extra config set MSWEA_MODEL_NAME claude-sonnet-4-20250514\n</code></pre> <p>Alternatively, you can directly edit the <code>.env</code> file in the config directory (the location is printed when you run <code>mini --help</code>).</p>"},{"location":"faq/#minutia","title":"Minutia","text":"Why is not needed a running shell session such a big deal? <p>Most agents so far kept a running shell session. Every action from the agent was executed in this session. However, this is far from trivial:</p> <ol> <li>It's not obvious when a command has terminated. Essentially you're just pasting input into the shell session, and press enter\u2014but when do you stop reading output?    We've experimented with various heuristics (watching PIDs, watching for the shell to go back to the prompt, etc.) but all of them were flaky.    The <code>mini</code> agent doesn't need any of this!</li> <li>Particularly bad commands from the LM can kill the shell session. Then what?</li> <li>Interrupting a command running in a shell session can also mess up the shell itself and can in particular interfere with all the following outputs you want to extract.</li> </ol> <p><code>mini</code> is different: There is no running shell session. Every action is executed as a subprocess, that means every action is independent of the previous ones (it is literally a <code>subprocess.run</code>/<code>os.system</code>/<code>docker exec</code> call).</p> <p>This means that the agent cannot even change directories or export environment variables. But you don't need this! You can always prefix <code>cd /path/to/project</code> or <code>export FOO=bar</code> to every action (and in fact some LMs like Claude will do that even if you don't ask them to).</p> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"quickstart/","title":"Quick start","text":"<p>Installation Options</p> pipuv (isolated)pipx (isolated)From source/dev <p>Use pip to install <code>mini</code> in your current environment:</p> <pre><code>pip install mini-swe-agent\n</code></pre> <p>And try our command line interface</p> <pre><code>mini  # simple UI\nmini -v  # visual UI\nmini-extra  # extra utilities\n</code></pre> <p>Use <code>uv</code>/<code>uvx</code> (installation) to install &amp; run the <code>mini</code> agent in an isolated environment.</p> <p>Quickly install + run:</p> <pre><code>uvx mini-swe-agent  # simple UI\nuvx mini-swe-agent -v  # visual UI\nuvx --from mini-swe-agent mini-extra  # extra utilities\n</code></pre> <p>Permanently install</p> <pre><code>uv tool install mini-swe-agent\n# then\nmini  # simple UI\nmini -v  # visual UI\nmini-extra  # extra utilities\n</code></pre> <p>Use pipx (installation) to install &amp; run <code>mini</code> in an isolated environment.</p> <p>Quick install + run:</p> <pre><code># Simple UI\npipx run mini-swe-agent\n# Textual UI\npipx run mini-swe-agent -v\n# Extra utilities\npipx run --spec mini-swe-agent mini-extra\n</code></pre> <p>or for a persistent installation (recommended):</p> <pre><code>pipx install mini-swe-agent\n# then\nmini  # simple UI\nmini -v  # visual UI\nmini-extra  # extra utilities\n</code></pre> <p>If the invocation doesn't immediately work, you might need to run <code>pipx ensurepath</code>.</p> <p>For development or if you want to customize the agent:</p> <pre><code>git clone https://github.com/SWE-agent/mini-swe-agent.git\ncd mini-swe-agent\npip install -e .\n</code></pre> <p>Then run:</p> <pre><code>mini  # simple UI\nmini -v  # visual UI\nmini-extra  # extra utilities\n</code></pre> <p>Or pick a run script:</p> <pre><code>python minisweagent/run/hello_world.py\n</code></pre> <p>If you are planning to contribute, please also install the dev dependencies and <code>pre-commit</code> hooks:</p> <pre><code>pip install -e '.[dev]'\npip install pre-commit &amp;&amp; pre-commit install\n</code></pre> <p>To check your installation, you can run <code>pytest -n auto</code> in the root folder. This should run all tests in parallel (should take ~3min to run).</p> <p>Note that there are still some extra dependencies that are not installed by default (basically anything that is in an <code>.../extra/...</code> folder). If you truly want to get the maximal package, you can run <code>pip install -e '.[full]'</code></p> <p>Changelog</p> <p>Please see the github release notes for recent changes.</p> <p>Example Prompts</p> <p>Try mini-SWE-agent with these example prompts:</p> <ul> <li>Implement a Sudoku solver in python in the <code>sudoku</code> folder. Make sure the codebase is modular and well tested with pytest.</li> <li>Please run pytest on the current project, discover failing unittests and help me fix them. Always make sure to test the final solution.</li> <li>Help me document &amp; type my codebase by adding short docstrings and type hints.</li> </ul>"},{"location":"quickstart/#models","title":"Models","text":"<p>Models should be set up the first time you run <code>mini</code></p> <p>If you missed the setup wizard, just run <code>mini-extra config setup</code>, or take a look at the following section. If you want to use local models, please check this guide.</p> <p>Which model to use?</p> <p>We recommend using <code>claude-sonnet-4-20250514</code> for most tasks. You can check scores of different models at our SWE-bench (bash-only) leaderboard.</p>"},{"location":"quickstart/#setting-api-keys","title":"Setting API keys","text":"<p>There are several ways to set your API keys:</p> <ul> <li>Recommended: Run our setup script: <code>mini-extra config setup</code>. This should also run automatically the first time you run <code>mini</code>.</li> <li>Use <code>mini-extra config set ANTHROPIC_API_KEY &lt;your-api-key&gt;</code> to put the key in the <code>mini</code> config file.</li> <li>Export your key as an environment variable: <code>export ANTHROPIC_API_KEY=&lt;your-api-key&gt;</code> (this is not persistent if you restart your shell, unless you add it to your shell config, like <code>~/.bashrc</code> or <code>~/.zshrc</code>).</li> <li>If you only use a single model, you can also set <code>MSWEA_MODEL_API_KEY</code> (as environment variable or in the config file). This takes precedence over all other keys.</li> <li>If you run several agents in parallel, see our note about rotating anthropic keys here.</li> </ul> All the API key names <p>Here's a list of all the API key names available in <code>litellm</code>:</p> <pre><code>ALEPH_ALPHA_API_KEY\nALEPHALPHA_API_KEY\nANTHROPIC_API_KEY\nANYSCALE_API_KEY\nAZURE_AI_API_KEY\nAZURE_API_KEY\nAZURE_OPENAI_API_KEY\nBASETEN_API_KEY\nCEREBRAS_API_KEY\nCLARIFAI_API_KEY\nCLOUDFLARE_API_KEY\nCO_API_KEY\nCODESTRAL_API_KEY\nCOHERE_API_KEY\nDATABRICKS_API_KEY\nDEEPINFRA_API_KEY\nDEEPSEEK_API_KEY\nFEATHERLESS_AI_API_KEY\nFIREWORKS_AI_API_KEY\nFIREWORKS_API_KEY\nFIREWORKSAI_API_KEY\nGEMINI_API_KEY\nGROQ_API_KEY\nHUGGINGFACE_API_KEY\nINFINITY_API_KEY\nMARITALK_API_KEY\nMISTRAL_API_KEY\nNEBIUS_API_KEY\nNLP_CLOUD_API_KEY\nNOVITA_API_KEY\nNVIDIA_NIM_API_KEY\nOLLAMA_API_KEY\nOPENAI_API_KEY\nOPENAI_LIKE_API_KEY\nOPENROUTER_API_KEY\nOR_API_KEY\nPALM_API_KEY\nPERPLEXITYAI_API_KEY\nPREDIBASE_API_KEY\nPROVIDER_API_KEY\nREPLICATE_API_KEY\nTOGETHERAI_API_KEY\nVOLCENGINE_API_KEY\nVOYAGE_API_KEY\nWATSONX_API_KEY\nWX_API_KEY\nXAI_API_KEY\nXINFERENCE_API_KEY\n</code></pre>"},{"location":"quickstart/#selecting-a-model","title":"Selecting a model","text":"<ul> <li>Recommended: <code>mini-extra config setup</code> (should be run the first time you run <code>mini</code>) can set the default model for you</li> <li>All command line interfaces allow you to set the model name with <code>-m</code> or <code>--model</code>.</li> <li>In addition, you can set the default model with <code>mini-extra config set MSWEA_MODEL_NAME &lt;model-name&gt;</code>, by editing the global config file (shortcut: <code>mini-extra config edit</code>), or by setting the <code>MSWEA_MODEL_NAME</code> environment variable.</li> <li>You can also set your model in a config file (key <code>model_name</code> under <code>model</code>).</li> <li>If you want to use local models, please check this guide.</li> </ul>"},{"location":"quickstart/#gpt-5-and-friends","title":"GPT-5 and friends","text":"<p><code>gpt-5</code> and friends are not included in <code>litellm</code> yet, so we need to register them manually. For this, first create the following file:</p> model_registry.json <pre><code>{\n    \"gpt-5\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 1.25e-06,\n        \"output_cost_per_token\": 1e-05,\n        \"cache_read_input_token_cost\": 1.25e-07,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    },\n    \"gpt-5-mini\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 2.5e-07,\n        \"output_cost_per_token\": 2e-06,\n        \"cache_read_input_token_cost\": 2.5e-08,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    },\n    \"gpt-5-nano\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 5e-08,\n        \"output_cost_per_token\": 4e-07,\n        \"cache_read_input_token_cost\": 5e-09,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    },\n    \"gpt-5-chat\": {\n        \"max_tokens\": 32768,\n        \"max_input_tokens\": 1047576,\n        \"max_output_tokens\": 32768,\n        \"input_cost_per_token\": 5e-06,\n        \"output_cost_per_token\": 2e-05,\n        \"input_cost_per_token_batches\": 2.5e-06,\n        \"output_cost_per_token_batches\": 1e-05,\n        \"cache_read_input_token_cost\": 1.25e-06,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true\n    },\n    \"gpt-5-chat-latest\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 1.25e-06,\n        \"output_cost_per_token\": 1e-05,\n        \"cache_read_input_token_cost\": 1.25e-07,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    },\n    \"gpt-5-2025-08-07\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 1.25e-06,\n        \"output_cost_per_token\": 1e-05,\n        \"cache_read_input_token_cost\": 1.25e-07,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    },\n    \"gpt-5-mini-2025-08-07\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 2.5e-07,\n        \"output_cost_per_token\": 2e-06,\n        \"cache_read_input_token_cost\": 2.5e-08,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    },\n    \"gpt-5-nano-2025-08-07\": {\n        \"max_tokens\": 128000,\n        \"max_input_tokens\": 400000,\n        \"max_output_tokens\": 128000,\n        \"input_cost_per_token\": 5e-08,\n        \"output_cost_per_token\": 4e-07,\n        \"cache_read_input_token_cost\": 5e-09,\n        \"litellm_provider\": \"openai\",\n        \"mode\": \"chat\",\n        \"supported_endpoints\": [\n            \"/v1/chat/completions\",\n            \"/v1/batch\",\n            \"/v1/responses\"\n        ],\n        \"supported_modalities\": [\n            \"text\",\n            \"image\"\n        ],\n        \"supported_output_modalities\": [\n            \"text\"\n        ],\n        \"supports_pdf_input\": true,\n        \"supports_function_calling\": true,\n        \"supports_parallel_function_calling\": true,\n        \"supports_response_schema\": true,\n        \"supports_vision\": true,\n        \"supports_prompt_caching\": true,\n        \"supports_system_messages\": true,\n        \"supports_tool_choice\": true,\n        \"supports_native_streaming\": true,\n        \"supports_reasoning\": true\n    }\n}\n</code></pre> <p>Now tell <code>mini</code> where to find the file, e.g.,</p> <pre><code>mini-extra config set LITELLM_MODEL_REGISTRY_PATH $HOME/model_registry.json\n</code></pre> <p>Now you're good to go! The only thing to keep in mind is to</p> <ol> <li>Reference the model together with the provider, e.g., <code>openai/gpt-5</code> (rather than just <code>gpt-5</code>)</li> <li>Select a config file without temperature setting, e.g., <code>mini_no_temp.yaml</code></li> </ol> <p>Here's a few examples:</p> GPT-5GPT-5-miniGPT-5-nano <pre><code>mini -v -m openai/gpt-5 -c mini_no_temp\n</code></pre> <pre><code>mini -v -m openai/gpt-5-mini -c mini_no_temp\n</code></pre> <pre><code>mini -v -m openai/gpt-5-nano -c mini_no_temp\n</code></pre> <p>Or with the visual UI:</p> GPT-5GPT-5-miniGPT-5-nano <pre><code>mini -v -m openai/gpt-5 -c mini_no_temp\n</code></pre> <pre><code>mini -v -m openai/gpt-5-mini -c mini_no_temp\n</code></pre> <pre><code>mini -v -m openai/gpt-5-nano -c mini_no_temp\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"advanced/configuration/","title":"Configuration","text":"<p>Configuring mini</p> <ul> <li>This guide shows how to configure the <code>mini</code> agent.</li> <li>You should already be familiar with the quickstart guide.</li> <li>Want more? See the cookbook for subclassing &amp; developing your own agent.</li> </ul>"},{"location":"advanced/configuration/#environment-variables-and-global-configuration","title":"Environment variables and global configuration","text":"<p>Setting up models</p> <p>Setting up models is also covered in the quickstart guide.</p> <p>All global configuration can be either set as environment variables, or in the <code>.env</code> file (the exact location is printed when you run <code>mini</code>). Environment variables take precedence over variables set in the <code>.env</code> file.</p> <p>We provide several helper functions to update the global configuration.</p> <p>For example, to set the default model and API keys, you can run:</p> <pre><code>mini-extra config setup\n</code></pre> <p>or to update specific settings:</p> <pre><code>mini-extra config set KEY VALUE\n# e.g.,\nmini-extra config set MSWEA_MODEL_NAME \"claude-sonnet-4-20250514\"\nmini-extra config set MSWEA_MODEL_API_KEY \"sk-...\"\n</code></pre> <p>or to unset a key:</p> <pre><code>mini-extra config unset KEY\n# e.g.,\nmini-extra config unset MSWEA_MODEL_API_KEY\n</code></pre> <p>You can also edit the <code>.env</code> file directly and we provide a helper function for that:</p> <pre><code>mini-extra config edit\n</code></pre> <p>To set environment variables (recommended for temporary experiemntation or API keys):</p> <pre><code>export KEY=\"value\"\n# windows:\nsetx KEY \"value\"\n</code></pre>"},{"location":"advanced/configuration/#models-and-keys","title":"Models and keys","text":"<p>See also</p> <p>Read the quickstart guide first\u2014it already covers most of this.</p> <pre><code># Default model name\n# (default: not set)\nMSWEA_MODEL_NAME=\"claude-sonnet-4-20250514\"\n\n# Default API key\n# (default: not set)\nMSWEA_MODEL_API_KEY=\"sk-...\"\n</code></pre> <p>To register extra models to litellm (see local models for more details), you can either specify the path in the agent file, or set</p> <pre><code>LITELLM_MODEL_REGISTRY_PATH=\"/path/to/your/model/registry.json\"\n</code></pre> <p>For Anthropic models, you can also use <code>ANTHROPIC_API_KEYS</code> for advanced parallel execution:</p> <pre><code># Multiple Anthropic keys for parallel execution (separated by \"::\")\nANTHROPIC_API_KEYS=\"key1::key2::key3\"\n</code></pre> <p>This allows different threads to use different API keys to avoid prompt caching conflicts when running multiple agents in parallel.</p> <p>Global cost limits:</p> <pre><code># Global limit on number of model calls (0 = no limit)\n# (default: 0)\nMSWEA_GLOBAL_CALL_LIMIT=\"100\"\n\n# Global cost limit in dollars (0 = no limit)\n# (default: 0)\nMSWEA_GLOBAL_COST_LIMIT=\"10.00\"\n</code></pre>"},{"location":"advanced/configuration/#default-config-files","title":"Default config files","text":"<pre><code># Set a custom directory for agent config files in addition to the builtin ones\n# This allows to specify them by names\nMSWEA_CONFIG_DIR=\"/path/to/your/own/config/dir\"\n\n# Config path for mini run script\n# (default: package_dir / \"config\" / \"mini.yaml\")\nMSWEA_MINI_CONFIG_PATH=\"/path/to/your/own/config\"\n\n# Config path for GitHub issue script\n# (default: package_dir / \"config\" / \"github_issue.yaml\")\nMSWEA_GITHUB_CONFIG_PATH=\"/path/to/your/github/config.yaml\"\n\n# Custom style path for trajectory inspector\n# (default: package_dir / \"config\" / \"mini.tcss\")\nMSWEA_INSPECTOR_STYLE_PATH=\"/path/to/your/inspector/style.tcss\"\n\n# Custom style path for mini textual interface\n# (default: package_dir / \"config\" / \"mini.tcss\")\nMSWEA_MINI_STYLE_PATH=\"/path/to/your/mini/style.tcss\"\n</code></pre>"},{"location":"advanced/configuration/#default-run-files","title":"Default run files","text":"<pre><code># Default run script entry point for the main CLI\n# (default: \"minisweagent.run.mini\")\nMSWEA_DEFAULT_RUN=\"minisweagent.run.mini\"\n\n# Set to true to use visual mode by default for the main CLI\n# (default: false)\nMSWEA_VISUAL_MODE_DEFAULT=\"false\"\n</code></pre>"},{"location":"advanced/configuration/#agent-configuration-files","title":"Agent configuration files","text":"<p>Configuration files look like this:</p> Configuration file <pre><code>agent:\n  system_template: |\n    You are a helpful assistant that can interact with a computer.\n\n    Your response must contain exactly ONE bash code block with ONE command (or commands connected with &amp;&amp; or ||).\n    Include a THOUGHT section before your command where you explain your reasoning process.\n    Format your response as shown in &lt;format_example&gt;.\n\n    &lt;format_example&gt;\n    Your reasoning and analysis here. Explain why you want to perform the action.\n\n    ```bash\n    your_command_here\n    ```\n    &lt;/format_example&gt;\n\n    Failure to follow these rules will cause your response to be rejected.\n  instance_template: |\n    Please solve this issue: {{task}}\n\n    You can execute bash commands and edit files to implement the necessary changes.\n\n    ## Recommended Workflow\n\n    This workflows should be done step-by-step so that you can iterate on your changes and any possible problems.\n\n    1. Analyze the codebase by finding and reading relevant files\n    2. Create a script to reproduce the issue\n    3. Edit the source code to resolve the issue\n    4. Verify your fix works by running your script again\n    5. Test edge cases to ensure your fix is robust\n    6. Submit your changes and finish your work by issuing the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`.\n       Do not combine it with any other command. &lt;important&gt;After this command, you cannot continue working on this task.&lt;/important&gt;\n\n    ## Important Rules\n\n    1. Every response must contain exactly one action\n    2. The action must be enclosed in triple backticks\n    3. Directory or environment variable changes are not persistent. Every action is executed in a new subshell.\n       However, you can prefix any action with `MY_ENV_VAR=MY_VALUE cd /path/to/working/dir &amp;&amp; ...` or write/load environment variables from files\n\n    &lt;system_information&gt;\n    {{system}} {{release}} {{version}} {{machine}} {{processor}}\n    &lt;/system_information&gt;\n\n    ## Formatting your response\n\n    Here is an example of a correct response:\n\n    &lt;example_response&gt;\n    THOUGHT: I need to understand the structure of the repository first. Let me check what files are in the current directory to get a better understanding of the codebase.\n\n    ```bash\n    ls -la\n    ```\n    &lt;/example_response&gt;\n\n    ## Useful command examples\n\n    ### Create a new file:\n\n    ```bash\n    cat &lt;&lt;'EOF' &gt; newfile.py\n    import numpy as np\n    hello = \"world\"\n    print(hello)\n    EOF\n    ```\n\n    ### Edit files with sed:\n\n    {%- if system == \"Darwin\" -%}\n    &lt;important&gt;\n    You are on MacOS. For all the below examples, you need to use `sed -i ''` instead of `sed -i`.\n    &lt;/important&gt;\n    {%- endif -%}\n\n    ```bash\n    # Replace all occurrences\n    sed -i 's/old_string/new_string/g' filename.py\n\n    # Replace only first occurrence\n    sed -i 's/old_string/new_string/' filename.py\n\n    # Replace first occurrence on line 1\n    sed -i '1s/old_string/new_string/' filename.py\n\n    # Replace all occurrences in lines 1-10\n    sed -i '1,10s/old_string/new_string/g' filename.py\n    ```\n\n    ### View file content:\n\n    ```bash\n    # View specific lines with numbers\n    nl -ba filename.py | sed -n '10,20p'\n    ```\n\n    ### Any other command you want to run\n\n    ```bash\n    anything\n    ```\n  action_observation_template: |\n    &lt;returncode&gt;{{output.returncode}}&lt;/returncode&gt;\n    {% if output.output | length &lt; 10000 -%}\n    &lt;output&gt;\n    {{ output.output -}}\n    &lt;/output&gt;\n    {%- else -%}\n    &lt;warning&gt;\n    The output of your last command was too long.\n    Please try a different command that produces less output.\n    If you're looking at a file you can try use head, tail or sed to view a smaller number of lines selectively.\n    If you're using grep or find and it produced too much output, you can use a more selective search pattern.\n    If you really need to see something from the full command's output, you can redirect output to a file and then search in that file.\n    &lt;/warning&gt;\n    {%- set elided_chars = output.output | length - 10000 -%}\n    &lt;output_head&gt;\n    {{ output.output[:5000] }}\n    &lt;/output_head&gt;\n    &lt;elided_chars&gt;\n    {{ elided_chars }} characters elided\n    &lt;/elided_chars&gt;\n    &lt;output_tail&gt;\n    {{ output.output[-5000:] }}\n    &lt;/output_tail&gt;\n    {%- endif -%}\n  format_error_template: |\n    Please always provide EXACTLY ONE action in triple backticks, found {{actions|length}} actions.\n    If you want to end the task, please issue the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`\n    without any other command.\n    Else, please format your response exactly as follows:\n\n    &lt;response_example&gt;\n    Here are some thoughts about why you want to perform the action.\n\n    ```bash\n    &lt;action&gt;\n    ```\n    &lt;/response_example&gt;\n\n    Note: In rare cases, if you need to reference a similar format in your command, you might have\n    to proceed in two steps, first writing TRIPLEBACKTICKSBASH, then replacing them with ```bash.\n  step_limit: 0.\n  cost_limit: 3.\n  mode: confirm\nenvironment:\n  env:\n    PAGER: cat\n    MANPAGER: cat\n    LESS: -R\n    PIP_PROGRESS_BAR: 'off'\n    TQDM_DISABLE: '1'\nmodel:\n  model_kwargs:\n    temperature: 0.0\n    drop_params: true\n</code></pre> <p>We use Jinja2 to render templates (e.g., the instance template). TL;DR: You include variables with double curly braces, e.g. <code>{{task}}</code>, but you can also do fairly complicated logic like this:</p> Example: Dealing with long observations <pre><code>&lt;returncode&gt;{{output.returncode}}&lt;/returncode&gt;\n{% if output.output | length &lt; 10000 -%}\n    &lt;output&gt;\n        {{ output.output -}}\n    &lt;/output&gt;\n{%- else -%}\n    &lt;warning&gt;\n        The output of your last command was too long.\n        Please try a different command that produces less output.\n        If you're looking at a file you can try use head, tail or sed to view a smaller number of lines selectively.\n        If you're using grep or find and it produced too much output, you can use a more selective search pattern.\n        If you really need to see something from the full command's output, you can redirect output to a file and then search in that file.\n    &lt;/warning&gt;\n\n    {%- set elided_chars = output.output | length - 10000 -%}\n\n    &lt;output_head&gt;\n        {{ output.output[:5000] }}\n    &lt;/output_head&gt;\n\n    &lt;elided_chars&gt;\n        {{ elided_chars }} characters elided\n    &lt;/elided_chars&gt;\n\n    &lt;output_tail&gt;\n        {{ output.output[-5000:] }}\n    &lt;/output_tail&gt;\n{%- endif -%}\n</code></pre> <p>In all builtin agents, you can use the following variables:</p> <ul> <li>Environment variables</li> <li>Agent config variables</li> <li>Environment config variables</li> <li>Explicitly passed variables (<code>observation</code>, <code>task</code> etc.) depending on the template</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"advanced/control_flow/","title":"Agent control flow","text":"<p>Understanding the default agent</p> <ul> <li>This guide shows the control flow of the default agent.</li> <li>After this, you're ready to remix &amp; extend mini</li> </ul> <p>The following diagram shows the control flow of the mini agent:</p> <p>And here is the code that implements it:</p> Default agent class <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>\"\"\"Basic agent class. See https://mini-swe-agent.com/latest/advanced/control_flow/ for visual explanation.\"\"\"\n\nimport os\nimport platform\nimport re\nimport subprocess\nfrom collections.abc import Callable\nfrom dataclasses import asdict, dataclass\n\nfrom jinja2 import Template\n\nfrom minisweagent import Environment, Model\n\n\n@dataclass\nclass AgentConfig:\n    # The default settings are the bare minimum to run the agent. Take a look at the config files for improved settings.\n    system_template: str = \"You are a helpful assistant that can do anything.\"\n    instance_template: str = (\n        \"Your task: {{task}}. Please reply with a single shell command in triple backticks. \"\n        \"To finish, the first line of the output of the shell command must be 'COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT'.\"\n    )\n    timeout_template: str = (\n        \"The last command &lt;command&gt;{{action['action']}}&lt;/command&gt; timed out and has been killed.\\n\"\n        \"The output of the command was:\\n &lt;output&gt;\\n{{output}}\\n&lt;/output&gt;\\n\"\n        \"Please try another command and make sure to avoid those requiring interactive input.\"\n    )\n    format_error_template: str = \"Please always provide EXACTLY ONE action in triple backticks.\"\n    action_observation_template: str = \"Observation: {{output}}\"\n    step_limit: int = 0\n    cost_limit: float = 3.0\n\n\nclass NonTerminatingException(Exception):\n    \"\"\"Raised for conditions that can be handled by the agent.\"\"\"\n\n\nclass FormatError(NonTerminatingException):\n    \"\"\"Raised when the LM's output is not in the expected format.\"\"\"\n\n\nclass ExecutionTimeoutError(NonTerminatingException):\n    \"\"\"Raised when the action execution timed out.\"\"\"\n\n\nclass TerminatingException(Exception):\n    \"\"\"Raised for conditions that terminate the agent.\"\"\"\n\n\nclass Submitted(TerminatingException):\n    \"\"\"Raised when the LM declares that the agent has finished its task.\"\"\"\n\n\nclass LimitsExceeded(TerminatingException):\n    \"\"\"Raised when the agent has reached its cost or step limit.\"\"\"\n\n\nclass DefaultAgent:\n    def __init__(self, model: Model, env: Environment, *, config_class: Callable = AgentConfig, **kwargs):\n        self.config = config_class(**kwargs)\n        self.messages: list[dict] = []\n        self.model = model\n        self.env = env\n\n    def render_template(self, template: str, **kwargs) -&gt; str:\n        cs = asdict(self.config) | asdict(self.env.config) | asdict(self.model.config) | platform.uname()._asdict()\n        return Template(template).render(**kwargs, **cs, **os.environ)\n\n    def add_message(self, role: str, content: str, **kwargs):\n        self.messages.append({\"role\": role, \"content\": content, **kwargs})\n\n    def run(self, task: str) -&gt; tuple[str, str]:\n        \"\"\"Run step() until agent is finished. Return exit status &amp; message\"\"\"\n        self.messages = []\n        self.add_message(\"system\", self.render_template(self.config.system_template))\n        self.add_message(\"user\", self.render_template(self.config.instance_template, task=task))\n        while True:\n            try:\n                self.step()\n            except NonTerminatingException as e:\n                self.add_message(\"user\", str(e))\n            except TerminatingException as e:\n                self.add_message(\"user\", str(e))\n                return type(e).__name__, str(e)\n\n    def step(self) -&gt; dict:\n        \"\"\"Query the LM, execute the action, return the observation.\"\"\"\n        return self.get_observation(self.query())\n\n    def query(self) -&gt; dict:\n        \"\"\"Query the model and return the response.\"\"\"\n        if 0 &lt; self.config.step_limit &lt;= self.model.n_calls or 0 &lt; self.config.cost_limit &lt;= self.model.cost:\n            raise LimitsExceeded()\n        response = self.model.query(self.messages)\n        self.add_message(\"assistant\", **response)\n        return response\n\n    def get_observation(self, response: dict) -&gt; dict:\n        \"\"\"Execute the action and return the observation.\"\"\"\n        output = self.execute_action(self.parse_action(response))\n        observation = self.render_template(self.config.action_observation_template, output=output)\n        self.add_message(\"user\", observation)\n        return output\n\n    def parse_action(self, response: dict) -&gt; dict:\n        \"\"\"Parse the action from the message. Returns the action.\"\"\"\n        actions = re.findall(r\"```bash\\n(.*?)\\n```\", response[\"content\"], re.DOTALL)\n        if len(actions) == 1:\n            return {\"action\": actions[0].strip(), **response}\n        raise FormatError(self.render_template(self.config.format_error_template, actions=actions))\n\n    def execute_action(self, action: dict) -&gt; dict:\n        try:\n            output = self.env.execute(action[\"action\"])\n        except subprocess.TimeoutExpired as e:\n            output = e.output.decode(\"utf-8\", errors=\"replace\") if e.output else \"\"\n            raise ExecutionTimeoutError(\n                self.render_template(self.config.timeout_template, action=action, output=output)\n            )\n        except TimeoutError:\n            raise ExecutionTimeoutError(self.render_template(self.config.timeout_template, action=action, output=\"\"))\n        self.has_finished(output)\n        return output\n\n    def has_finished(self, output: dict[str, str]):\n        \"\"\"Raises Submitted exception with final output if the agent has finished its task.\"\"\"\n        lines = output.get(\"output\", \"\").lstrip().splitlines()\n        if lines and lines[0].strip() in [\"MINI_SWE_AGENT_FINAL_OUTPUT\", \"COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT\"]:\n            raise Submitted(\"\\n\".join(lines[1:]))\n</code></pre> <p>Essentially, <code>DefaultAgent.run</code> calls <code>DefaultAgent.step</code> in a loop until the agent has finished its task.</p> <p>The <code>step</code> method is the core of the agent. It does the following:</p> <ol> <li>Queries the model for a response based on the current messages (<code>DefaultAgent.query</code>, calling <code>Model.query</code>)</li> <li>Parses the response to get the action, i.e., the shell command to execute (<code>DefaultAgent.parse_action</code>)</li> <li>Executes the action in the environment (<code>DefaultAgent.execute_action</code>, calling <code>Environment.execute</code>)</li> <li>Renders the observation message with <code>DefaultAgent.render_template</code></li> <li>Adds the observation to the messages</li> </ol> <p>The interesting bit is how we handle error conditions and the finish condition: This uses exceptions of two types: <code>TerminatingException</code> and <code>NonTerminatingException</code>.</p> <ul> <li><code>TerminatingException</code> is raised when the agent has finished its task or we hit a limit (cost, step limit, etc.)</li> <li> <p><code>NonTerminatingException</code> is raised when the agent has not finished its task, but we want to continue the loop.    In this case, all we need to do is to add a new message to the messages list, so that the LM can see the new state.    There are two typical cases that we handle this way:</p> <ol> <li><code>TimeoutError</code>: the action took too long to execute (we show partial output)</li> <li><code>FormatError</code>: the output from the LM contained zero or multiple actions (we show the error message)</li> </ol> </li> </ul> <p>The <code>DefaultAgent.run</code> method catches these exceptions and handles them by adding the corresponding message to the messages list and continuing the loop.</p> <pre><code>while True:\n    try:\n        self.step()\n    except NonTerminatingException as e:\n        self.add_message(\"user\", str(e))\n    except TerminatingException as e:\n        self.add_message(\"user\", str(e))\n        return type(e).__name__, str(e)\n</code></pre> <p>Using exceptions for the control flow is a lot easier than passing around flags and states, especially when extending or subclassing the agent.</p>"},{"location":"advanced/cookbook/","title":"Cookbook","text":"<p>Remixing &amp; extending mini</p> <ul> <li>This guide shows how to mix the different components of the <code>mini</code> agent to create your own custom version.</li> <li>You might want to first take a look at the control flow of the default agent first</li> </ul> <p>Development setup</p> <p>Make sure to follow the dev setup instructions in quickstart.md.</p> <p>We provide several different entry points to the agent, for example hello world, or the default when calling <code>mini</code>.</p> <p>Want to cook up your custom version and the config is not enough? Just follow the recipe below:</p> <ol> <li>What's the control flow you need? Pick an agent class (e.g., simplest example, with human in the loop)</li> <li>How should actions be executed? Pick an environment class (e.g., local, or docker)</li> <li>How is the LM queried? Pick a model class (e.g., litellm)</li> <li>How to invoke the agent? Bind them all together in a run script, possibly reading from a config (e.g., hello world, or <code>mini</code> entry point)</li> </ol> <p>We aim to keep all of these components very simple, but offer lots of choice between them -- enough to cover a broad range of things that you might want to do.</p> <p>You can override the default entry point by setting the <code>MSWEA_DEFAULT_RUN</code> environment variable to the import path of your run script.</p>"},{"location":"advanced/cookbook/#mix-match","title":"Mix &amp; match","text":""},{"location":"advanced/cookbook/#models","title":"Models","text":"Hello world (use automatic model selection)Hello world (Anthropic)Hello world (Litellm) <pre><code>from minisweagent.agents.default import DefaultAgent\nfrom minisweagent.models import get_model\nfrom minisweagent.environments.local import LocalEnvironment\n\nmodel_name = \"claude-sonnet-4-20250514\"\n\nagent = DefaultAgent(\n    get_model(model_name=model_name),\n    LocalEnvironment(),\n)\nagent.run(task)\n</code></pre> <pre><code>from minisweagent.agents.default import DefaultAgent\nfrom minisweagent.models.anthropic_model import AnthropicModel\nfrom minisweagent.environments.local import LocalEnvironment\n\nmodel_name = \"claude-sonnet-4-20250514\"\n\nagent = DefaultAgent(\n    AnthropicModel(model_name=model_name),\n    LocalEnvironment(),\n)\nagent.run(task)\n</code></pre> <pre><code>from minisweagent.agents.default import DefaultAgent\nfrom minisweagent.models.litellm_model import LitellmModel\nfrom minisweagent.environments.local import LocalEnvironment\n\nmodel_name = \"gpt-4o\"\n\nagent = DefaultAgent(\n    LitellmModel(model_name=model_name),\n    LocalEnvironment(),\n)\nagent.run(task)\n</code></pre>"},{"location":"advanced/cookbook/#environments","title":"Environments","text":"Hello world with local executionHello world with docker execution <pre><code>from minisweagent.environments.local import LocalEnvironment\n\nagent = DefaultAgent(\n    LitellmModel(model_name=model_name),\n    LocalEnvironment(),\n)\n</code></pre> <pre><code>from minisweagent.environments.docker import DockerEnvironment\n\nagent = DefaultAgent(\n    LitellmModel(model_name=model_name),\n    DockerEnvironment(),\n)\n</code></pre>"},{"location":"advanced/cookbook/#agents","title":"Agents","text":"Default agentHuman in the loopHuman in the loop (textual) <pre><code>from minisweagent.agents.default import DefaultAgent\nfrom minisweagent.models import get_model\nfrom minisweagent.environments.local import LocalEnvironment\n\nagent = DefaultAgent(\n    get_model(model_name=model_name),\n    LocalEnvironment(),\n)\n</code></pre> <pre><code>from minisweagent.agents.interactive import InteractiveAgent\nfrom minisweagent.models import get_model\nfrom minisweagent.environments.local import LocalEnvironment\n\nagent = InteractiveAgent(\n    LitellmModel(model_name=model_name),\n    LocalEnvironment(),\n)\n</code></pre> <pre><code>from minisweagent.agents.interactive_textual import TextualAgent\nfrom minisweagent.models import get_model\nfrom minisweagent.environments.local import LocalEnvironment\n\nagent = TextualAgent(\n    LitellmModel(model_name=model_name),\n    LocalEnvironment(),\n)\n</code></pre>"},{"location":"advanced/cookbook/#advanced","title":"Advanced","text":""},{"location":"advanced/cookbook/#customizing-execution","title":"Customizing execution","text":"<p>An agent that uses python function for some actions:</p> Subclassing the agentSubclassing the environment <pre><code>from minisweagent.agents.default import DefaultAgent\nimport shlex\n\ndef python_function(*args) -&gt; dict:\n    ...\n    return {\"output\": \"...\"}\n\nclass AgentWithPythonFunctions(DefaultAgent):\n    def execute_action(self, action: dict) -&gt; dict:\n        if action[\"action\"].startswith(\"python_function\"):\n            args = shlex.split(action[\"action\"].removeprefix(\"python_function\").strip())\n            return python_function(*args)\n        return super().execute_action(action)\n</code></pre> <pre><code>from minisweagent.agents.default import DefaultAgent\nimport shlex\n\ndef python_function(*args) -&gt; dict:\n    ...\n    return {\"output\": \"...\"}\n\nclass EnvironmentWithPythonFunctions(LocalEnvironment):\n    def execute(self, command: str, cwd: str = \"\") -&gt; dict:\n        if command.startswith(\"python_function\"):\n            args = shlex.split(command.removeprefix(\"python_function\").strip())\n            return python_function(*args)\n        return super().execute(command, cwd)\n\nagent = DefaultAgent(\n    LitellmModel(model_name=model_name),\n    EnvironmentWithPythonFunctions(),\n)\n</code></pre> <p>An agent that exits when the <code>submit</code> command is issued:</p> Subclassing the agentSubclassing the environment <pre><code>from minisweagent.agents.default import DefaultAgent, Submitted\n\nclass AgentQuitsOnSubmit(DefaultAgent):\n    def execute_action(self, action: dict) -&gt; dict:\n        if action[\"action\"] == \"submit\":\n            # The `Submitted` exception will be caught by the agent and\n            # the final output will be printed.\n            raise Submitted(\"The agent has finished its task.\")\n        return super().execute_action(action)\n</code></pre> <pre><code>from minisweagent.agents.default import DefaultAgent, Submitted\nfrom minisweagent.environments.local import LocalEnvironment\n\nclass EnvironmentQuitsOnSubmit(LocalEnvironment):\n    def execute(self, command: str, cwd: str = \"\") -&gt; dict:\n        if command == \"submit\":\n            raise Submitted(\"The agent has finished its task.\")\n        return super().execute(command, cwd)\n\nagent = DefaultAgent(\n    LitellmModel(model_name=model_name),\n    EnvironmentQuitsOnSubmit(),\n)\n</code></pre> <p>An agent that validates actions before execution (also an example of how to use an extended config class):</p> Subclassing the agentSubclassing the environment <pre><code>import re\nfrom dataclasses import dataclass\nfrom minisweagent.agents.default import (\n    DefaultAgent, NonTerminatingException, DefaultAgentConfig\n)\n\n@dataclass\nclass ValidatingAgentConfig(DefaultAgentConfig):\n    forbidden_patterns: list[str] = [\n        r\"rm -rf /\",\n        r\"sudo.*passwd\",\n        r\"mkfs\\.\",\n    ]\n\nclass ValidatingAgent(DefaultAgent):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs, config_class=ValidatingAgentConfig)\n\n    def execute_action(self, action: dict) -&gt; dict:\n        for pattern in self.config.forbidden_patterns:\n            if re.search(pattern, action[\"action\"], re.IGNORECASE):\n                raise NonTerminatingException(\"Action blocked\")\n        return super().execute_action(action)\n</code></pre> <pre><code>import re\nfrom dataclasses import dataclass\nfrom minisweagent.agents.default import (\n    DefaultAgent, NonTerminatingException, DefaultAgentConfig\n)\nfrom minisweagent.environments.local import LocalEnvironment\n\n@dataclass\nclass EnvironmentWithForbiddenPatternsConfig(LocalEnvironmentConfig):\n    forbidden_patterns: list[str] = [\n        r\"rm -rf /\",\n        r\"sudo.*passwd\",\n        r\"mkfs\\.\",\n    ]\n\nclass EnvironmentWithForbiddenPatterns(LocalEnvironment):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs, config_class=EnvironmentWithForbiddenPatternsConfig)\n\n    def execute(self, command: str, cwd: str = \"\") -&gt; dict:\n        for pattern in self.config.forbidden_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                raise NonTerminatingException(\"Action blocked\")\n        return super().execute(command, cwd)\n\nagent = DefaultAgent(\n    LitellmModel(model_name=model_name),\n    EnvironmentWithForbiddenPatterns(),\n)\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"advanced/local_models/","title":"Local models","text":"<p>Local models</p> <ul> <li>This guide shows how to set up local models.</li> <li>You should already be familiar with the quickstart guide.</li> <li>You should also quickly skim the configuration guide to understand   the global configuration and configuration files.</li> </ul> <p>Examples</p> <ul> <li>Issue #303 has several examples of how to use local models.</li> <li>We also welcome concrete examples of how to use local models per pull request into this guide.</li> </ul>"},{"location":"advanced/local_models/#using-litellm","title":"Using litellm","text":"<p>Currently, all models are supported via <code>litellm</code> (but if you have specific needs, we're open to add more specific model classes in the `models submodule).</p> <p>If you use local models, you most likely need to add some extra keywords to the <code>litellm</code> call. This is done with the <code>model_kwargs</code> dictionary which is directly passed to <code>litellm.completion</code>.</p> <p>In other words, this is how we invoke litellm:</p> <pre><code>litellm.completion(\n    model=model_name,\n    messages=messages,\n    **model_kwargs\n)\n</code></pre> Complete model class <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>import json\nimport logging\nimport os\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nimport litellm\nfrom tenacity import (\n    before_sleep_log,\n    retry,\n    retry_if_not_exception_type,\n    stop_after_attempt,\n    wait_exponential,\n)\n\nfrom minisweagent.models import GLOBAL_MODEL_STATS\n\nlogger = logging.getLogger(\"litellm_model\")\n\n\n@dataclass\nclass LitellmModelConfig:\n    model_name: str\n    model_kwargs: dict[str, Any] = field(default_factory=dict)\n    litellm_model_registry: Path | str | None = os.getenv(\"LITELLM_MODEL_REGISTRY_PATH\")\n\n\nclass LitellmModel:\n    def __init__(self, **kwargs):\n        self.config = LitellmModelConfig(**kwargs)\n        self.cost = 0.0\n        self.n_calls = 0\n        if self.config.litellm_model_registry and Path(self.config.litellm_model_registry).is_file():\n            litellm.utils.register_model(json.loads(Path(self.config.litellm_model_registry).read_text()))\n\n    @retry(\n        stop=stop_after_attempt(10),\n        wait=wait_exponential(multiplier=1, min=4, max=60),\n        before_sleep=before_sleep_log(logger, logging.WARNING),\n        retry=retry_if_not_exception_type(\n            (\n                litellm.exceptions.UnsupportedParamsError,\n                litellm.exceptions.NotFoundError,\n                litellm.exceptions.PermissionDeniedError,\n                litellm.exceptions.ContextWindowExceededError,\n                litellm.exceptions.APIError,\n                litellm.exceptions.AuthenticationError,\n                KeyboardInterrupt,\n            )\n        ),\n    )\n    def _query(self, messages: list[dict[str, str]], **kwargs):\n        try:\n            return litellm.completion(\n                model=self.config.model_name, messages=messages, **(self.config.model_kwargs | kwargs)\n            )\n        except litellm.exceptions.AuthenticationError as e:\n            e.message += \" You can permanently set your API key with `mini-extra config set KEY VALUE`.\"\n            raise e\n\n    def query(self, messages: list[dict[str, str]], **kwargs) -&gt; dict:\n        response = self._query(messages, **kwargs)\n        # cost = litellm.cost_calculator.completion_cost(response)  # \u30b3\u30b9\u30c8\u8a08\u7b97\u3092\u7121\u52b9\u5316\n        self.n_calls += 1\n        # self.cost += cost  # \u30b3\u30b9\u30c8\u8ffd\u52a0\u3092\u7121\u52b9\u5316\n        # GLOBAL_MODEL_STATS.add(cost)  # \u30b0\u30ed\u30fc\u30d0\u30eb\u7d71\u8a08\u3078\u306e\u8ffd\u52a0\u3092\u7121\u52b9\u5316\n        GLOBAL_MODEL_STATS.add(0)  # \u30b3\u30b9\u30c80\u3067\u8ffd\u52a0\uff08\u547c\u3073\u51fa\u3057\u56de\u6570\u306e\u307f\u30ab\u30a6\u30f3\u30c8\uff09\n        return {\n            \"content\": response.choices[0].message.content or \"\",  # type: ignore\n        }\n</code></pre> <p>You can set <code>model_kwargs</code> in an agent config file like the following one:</p> Default configuration file <pre><code>agent:\n  system_template: |\n    You are a helpful assistant that can interact with a computer.\n\n    Your response must contain exactly ONE bash code block with ONE command (or commands connected with &amp;&amp; or ||).\n    Include a THOUGHT section before your command where you explain your reasoning process.\n    Format your response as shown in &lt;format_example&gt;.\n\n    &lt;format_example&gt;\n    Your reasoning and analysis here. Explain why you want to perform the action.\n\n    ```bash\n    your_command_here\n    ```\n    &lt;/format_example&gt;\n\n    Failure to follow these rules will cause your response to be rejected.\n  instance_template: |\n    Please solve this issue: {{task}}\n\n    You can execute bash commands and edit files to implement the necessary changes.\n\n    ## Recommended Workflow\n\n    This workflows should be done step-by-step so that you can iterate on your changes and any possible problems.\n\n    1. Analyze the codebase by finding and reading relevant files\n    2. Create a script to reproduce the issue\n    3. Edit the source code to resolve the issue\n    4. Verify your fix works by running your script again\n    5. Test edge cases to ensure your fix is robust\n    6. Submit your changes and finish your work by issuing the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`.\n       Do not combine it with any other command. &lt;important&gt;After this command, you cannot continue working on this task.&lt;/important&gt;\n\n    ## Important Rules\n\n    1. Every response must contain exactly one action\n    2. The action must be enclosed in triple backticks\n    3. Directory or environment variable changes are not persistent. Every action is executed in a new subshell.\n       However, you can prefix any action with `MY_ENV_VAR=MY_VALUE cd /path/to/working/dir &amp;&amp; ...` or write/load environment variables from files\n\n    &lt;system_information&gt;\n    {{system}} {{release}} {{version}} {{machine}} {{processor}}\n    &lt;/system_information&gt;\n\n    ## Formatting your response\n\n    Here is an example of a correct response:\n\n    &lt;example_response&gt;\n    THOUGHT: I need to understand the structure of the repository first. Let me check what files are in the current directory to get a better understanding of the codebase.\n\n    ```bash\n    ls -la\n    ```\n    &lt;/example_response&gt;\n\n    ## Useful command examples\n\n    ### Create a new file:\n\n    ```bash\n    cat &lt;&lt;'EOF' &gt; newfile.py\n    import numpy as np\n    hello = \"world\"\n    print(hello)\n    EOF\n    ```\n\n    ### Edit files with sed:\n\n    {%- if system == \"Darwin\" -%}\n    &lt;important&gt;\n    You are on MacOS. For all the below examples, you need to use `sed -i ''` instead of `sed -i`.\n    &lt;/important&gt;\n    {%- endif -%}\n\n    ```bash\n    # Replace all occurrences\n    sed -i 's/old_string/new_string/g' filename.py\n\n    # Replace only first occurrence\n    sed -i 's/old_string/new_string/' filename.py\n\n    # Replace first occurrence on line 1\n    sed -i '1s/old_string/new_string/' filename.py\n\n    # Replace all occurrences in lines 1-10\n    sed -i '1,10s/old_string/new_string/g' filename.py\n    ```\n\n    ### View file content:\n\n    ```bash\n    # View specific lines with numbers\n    nl -ba filename.py | sed -n '10,20p'\n    ```\n\n    ### Any other command you want to run\n\n    ```bash\n    anything\n    ```\n  action_observation_template: |\n    &lt;returncode&gt;{{output.returncode}}&lt;/returncode&gt;\n    {% if output.output | length &lt; 10000 -%}\n    &lt;output&gt;\n    {{ output.output -}}\n    &lt;/output&gt;\n    {%- else -%}\n    &lt;warning&gt;\n    The output of your last command was too long.\n    Please try a different command that produces less output.\n    If you're looking at a file you can try use head, tail or sed to view a smaller number of lines selectively.\n    If you're using grep or find and it produced too much output, you can use a more selective search pattern.\n    If you really need to see something from the full command's output, you can redirect output to a file and then search in that file.\n    &lt;/warning&gt;\n    {%- set elided_chars = output.output | length - 10000 -%}\n    &lt;output_head&gt;\n    {{ output.output[:5000] }}\n    &lt;/output_head&gt;\n    &lt;elided_chars&gt;\n    {{ elided_chars }} characters elided\n    &lt;/elided_chars&gt;\n    &lt;output_tail&gt;\n    {{ output.output[-5000:] }}\n    &lt;/output_tail&gt;\n    {%- endif -%}\n  format_error_template: |\n    Please always provide EXACTLY ONE action in triple backticks, found {{actions|length}} actions.\n    If you want to end the task, please issue the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`\n    without any other command.\n    Else, please format your response exactly as follows:\n\n    &lt;response_example&gt;\n    Here are some thoughts about why you want to perform the action.\n\n    ```bash\n    &lt;action&gt;\n    ```\n    &lt;/response_example&gt;\n\n    Note: In rare cases, if you need to reference a similar format in your command, you might have\n    to proceed in two steps, first writing TRIPLEBACKTICKSBASH, then replacing them with ```bash.\n  step_limit: 0.\n  cost_limit: 3.\n  mode: confirm\nenvironment:\n  env:\n    PAGER: cat\n    MANPAGER: cat\n    LESS: -R\n    PIP_PROGRESS_BAR: 'off'\n    TQDM_DISABLE: '1'\nmodel:\n  model_kwargs:\n    temperature: 0.0\n    drop_params: true\n</code></pre> <p>Updating the default <code>mini</code> configuration file</p> <p>You can set the <code>MSWEA_MINI_CONFIG_PATH</code> setting to set path to the default <code>mini</code> configuration file. This will allow you to override the default configuration file with your own. See the configuration guide for more details.</p> <p>In the last section, you can add</p> <pre><code>model:\n  model_name: \"my-local-model\"\n  model_kwargs:\n    custom_llm_provider: \"openai\"\n    ...\n  ...\n</code></pre> <p>The other part that you most likely need to figure out are costs. There are two ways to do this with <code>litellm</code>:</p> <ol> <li>You set up a litellm proxy server (which gives you a lot of control over all the LM calls)</li> <li>You update the model registry (next section)</li> </ol>"},{"location":"advanced/local_models/#updating-the-model-registry","title":"Updating the model registry","text":"<p>LiteLLM get its cost and model metadata from this file. You can override or add data from this file if it's outdated or missing your desired model by including a custom registry file.</p> <p>The model registry JSON file should follow LiteLLM's format:</p> <pre><code>{\n  \"my-custom-model\": {\n    \"max_tokens\": 4096,\n    \"input_cost_per_token\": 0.0001,\n    \"output_cost_per_token\": 0.0002,\n    \"litellm_provider\": \"openai\",\n    \"mode\": \"chat\"\n  },\n  \"my-local-model\": {\n    \"max_tokens\": 8192,\n    \"input_cost_per_token\": 0.0,\n    \"output_cost_per_token\": 0.0,\n    \"litellm_provider\": \"ollama\",\n    \"mode\": \"chat\"\n  }\n}\n</code></pre> <p>There are two ways of setting the path to the model registry:</p> <ol> <li>Set <code>LITELLM_MODEL_REGISTRY_PATH</code> (e.g., <code>mini-extra config set LITELLM_MODEL_REGISTRY_PATH /path/to/model_registry.json</code>)</li> <li>Set <code>litellm_model_registry</code> in the agent config file</li> </ol> <pre><code>model:\n  litellm_model_registry: \"/path/to/model_registry.json\"\n  ...\n...\n</code></pre>"},{"location":"advanced/local_models/#concrete-examples","title":"Concrete examples","text":"<p>Help us fill this section!</p> <p>We welcome concrete examples of how to use local models per pull request into this guide. Please add your example here.</p>"},{"location":"reference/","title":"API Reference","text":"<p>This section provides detailed documentation for all classes and modules in mini-SWE-agent.</p>"},{"location":"reference/#agents","title":"Agents","text":"<ul> <li>DefaultAgent - The minimal default agent implementation</li> <li>InteractiveAgent - Agent with human-in-the-loop functionality</li> <li>TextualAgent - Agent with interactive TUI using Textual</li> </ul>"},{"location":"reference/#models","title":"Models","text":"<ul> <li>LitellmModel - Wrapper for LiteLLM models (supports most LLM providers)</li> <li>AnthropicModel - Specialized interface for Anthropic models</li> <li>DeterministicModel - Deterministic models for testing</li> <li>Model Utilities - Convenience functions for model selection and configuration</li> </ul>"},{"location":"reference/#environments","title":"Environments","text":"<ul> <li>LocalEnvironment - Execute commands in the local environment</li> <li>DockerEnvironment - Execute commands in Docker containers</li> <li>SwerexDockerEnvironment - Extended Docker environment with SWE-Rex integration</li> </ul>"},{"location":"reference/#run-scripts","title":"Run Scripts","text":"<p>Entry points and command-line interfaces:</p> <ul> <li>Hello World - Simple example usage</li> <li>mini - Interactive local execution</li> <li>GitHub Issue - GitHub issue solver</li> <li>SWE-bench - SWE-bench evaluation script</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/agents/default/","title":"DefaultAgent","text":"<p>Understanding the control flow</p> <p>Check out the control flow guide for a visual explanation of the agent's control flow following this picture:</p> <p> </p> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig","title":"minisweagent.agents.default.AgentConfig  <code>dataclass</code>","text":"<pre><code>AgentConfig(\n    system_template: str = \"You are a helpful assistant that can do anything.\",\n    instance_template: str = \"Your task: {{task}}. Please reply with a single shell command in triple backticks. To finish, the first line of the output of the shell command must be 'COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT'.\",\n    timeout_template: str = \"The last command &lt;command&gt;{{action['action']}}&lt;/command&gt; timed out and has been killed.\\nThe output of the command was:\\n &lt;output&gt;\\n{{output}}\\n&lt;/output&gt;\\nPlease try another command and make sure to avoid those requiring interactive input.\",\n    format_error_template: str = \"Please always provide EXACTLY ONE action in triple backticks.\",\n    action_observation_template: str = \"Observation: {{output}}\",\n    step_limit: int = 0,\n    cost_limit: float = 3.0,\n)\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.system_template","title":"system_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>system_template: str = (\n    \"You are a helpful assistant that can do anything.\"\n)\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.instance_template","title":"instance_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instance_template: str = \"Your task: {{task}}. Please reply with a single shell command in triple backticks. To finish, the first line of the output of the shell command must be 'COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT'.\"\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.timeout_template","title":"timeout_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout_template: str = \"The last command &lt;command&gt;{{action['action']}}&lt;/command&gt; timed out and has been killed.\\nThe output of the command was:\\n &lt;output&gt;\\n{{output}}\\n&lt;/output&gt;\\nPlease try another command and make sure to avoid those requiring interactive input.\"\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.format_error_template","title":"format_error_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format_error_template: str = \"Please always provide EXACTLY ONE action in triple backticks.\"\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.action_observation_template","title":"action_observation_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>action_observation_template: str = \"Observation: {{output}}\"\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.step_limit","title":"step_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>step_limit: int = 0\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.AgentConfig.cost_limit","title":"cost_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cost_limit: float = 3.0\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent","title":"minisweagent.agents.default.DefaultAgent","text":"<pre><code>DefaultAgent(\n    model: Model,\n    env: Environment,\n    *,\n    config_class: Callable = AgentConfig,\n    **kwargs,\n)\n</code></pre> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def __init__(self, model: Model, env: Environment, *, config_class: Callable = AgentConfig, **kwargs):\n    self.config = config_class(**kwargs)\n    self.messages: list[dict] = []\n    self.model = model\n    self.env = env\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config_class(**kwargs)\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.messages","title":"messages  <code>instance-attribute</code>","text":"<pre><code>messages: list[dict] = []\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.env","title":"env  <code>instance-attribute</code>","text":"<pre><code>env = env\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.render_template","title":"render_template","text":"<pre><code>render_template(template: str, **kwargs) -&gt; str\n</code></pre> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def render_template(self, template: str, **kwargs) -&gt; str:\n    cs = asdict(self.config) | asdict(self.env.config) | asdict(self.model.config) | platform.uname()._asdict()\n    return Template(template).render(**kwargs, **cs, **os.environ)\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.add_message","title":"add_message","text":"<pre><code>add_message(role: str, content: str, **kwargs)\n</code></pre> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def add_message(self, role: str, content: str, **kwargs):\n    self.messages.append({\"role\": role, \"content\": content, **kwargs})\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.run","title":"run","text":"<pre><code>run(task: str) -&gt; tuple[str, str]\n</code></pre> <p>Run step() until agent is finished. Return exit status &amp; message</p> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def run(self, task: str) -&gt; tuple[str, str]:\n    \"\"\"Run step() until agent is finished. Return exit status &amp; message\"\"\"\n    self.messages = []\n    self.add_message(\"system\", self.render_template(self.config.system_template))\n    self.add_message(\"user\", self.render_template(self.config.instance_template, task=task))\n    while True:\n        try:\n            self.step()\n        except NonTerminatingException as e:\n            self.add_message(\"user\", str(e))\n        except TerminatingException as e:\n            self.add_message(\"user\", str(e))\n            return type(e).__name__, str(e)\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.step","title":"step","text":"<pre><code>step() -&gt; dict\n</code></pre> <p>Query the LM, execute the action, return the observation.</p> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def step(self) -&gt; dict:\n    \"\"\"Query the LM, execute the action, return the observation.\"\"\"\n    return self.get_observation(self.query())\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.query","title":"query","text":"<pre><code>query() -&gt; dict\n</code></pre> <p>Query the model and return the response.</p> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def query(self) -&gt; dict:\n    \"\"\"Query the model and return the response.\"\"\"\n    if 0 &lt; self.config.step_limit &lt;= self.model.n_calls or 0 &lt; self.config.cost_limit &lt;= self.model.cost:\n        raise LimitsExceeded()\n    response = self.model.query(self.messages)\n    self.add_message(\"assistant\", **response)\n    return response\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.get_observation","title":"get_observation","text":"<pre><code>get_observation(response: dict) -&gt; dict\n</code></pre> <p>Execute the action and return the observation.</p> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def get_observation(self, response: dict) -&gt; dict:\n    \"\"\"Execute the action and return the observation.\"\"\"\n    output = self.execute_action(self.parse_action(response))\n    observation = self.render_template(self.config.action_observation_template, output=output)\n    self.add_message(\"user\", observation)\n    return output\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.parse_action","title":"parse_action","text":"<pre><code>parse_action(response: dict) -&gt; dict\n</code></pre> <p>Parse the action from the message. Returns the action.</p> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def parse_action(self, response: dict) -&gt; dict:\n    \"\"\"Parse the action from the message. Returns the action.\"\"\"\n    actions = re.findall(r\"```bash\\n(.*?)\\n```\", response[\"content\"], re.DOTALL)\n    if len(actions) == 1:\n        return {\"action\": actions[0].strip(), **response}\n    raise FormatError(self.render_template(self.config.format_error_template, actions=actions))\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.execute_action","title":"execute_action","text":"<pre><code>execute_action(action: dict) -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def execute_action(self, action: dict) -&gt; dict:\n    try:\n        output = self.env.execute(action[\"action\"])\n    except subprocess.TimeoutExpired as e:\n        output = e.output.decode(\"utf-8\", errors=\"replace\") if e.output else \"\"\n        raise ExecutionTimeoutError(\n            self.render_template(self.config.timeout_template, action=action, output=output)\n        )\n    except TimeoutError:\n        raise ExecutionTimeoutError(self.render_template(self.config.timeout_template, action=action, output=\"\"))\n    self.has_finished(output)\n    return output\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.DefaultAgent.has_finished","title":"has_finished","text":"<pre><code>has_finished(output: dict[str, str])\n</code></pre> <p>Raises Submitted exception with final output if the agent has finished its task.</p> Source code in <code>src/minisweagent/agents/default.py</code> <pre><code>def has_finished(self, output: dict[str, str]):\n    \"\"\"Raises Submitted exception with final output if the agent has finished its task.\"\"\"\n    lines = output.get(\"output\", \"\").lstrip().splitlines()\n    if lines and lines[0].strip() in [\"MINI_SWE_AGENT_FINAL_OUTPUT\", \"COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT\"]:\n        raise Submitted(\"\\n\".join(lines[1:]))\n</code></pre>"},{"location":"reference/agents/default/#minisweagent.agents.default.NonTerminatingException","title":"minisweagent.agents.default.NonTerminatingException","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for conditions that can be handled by the agent.</p>"},{"location":"reference/agents/default/#minisweagent.agents.default.TerminatingException","title":"minisweagent.agents.default.TerminatingException","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for conditions that terminate the agent.</p>"},{"location":"reference/agents/interactive/","title":"Interactive","text":"<p>See also</p> <ul> <li>This agent subclass builds on top of the default agent, make sure to read that first.</li> <li>This class powers the <code>mini</code> command line tool, see usage for more details.</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive","title":"minisweagent.agents.interactive","text":"<p>A small generalization of the default agent that puts the user in the loop.</p> <p>There are three modes: - human: commands issued by the user are executed immediately - confirm: commands issued by the LM but not whitelisted are confirmed by the user - yolo: commands issued by the LM are executed immediately without confirmation</p>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = Console(highlight=False)\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.prompt_session","title":"prompt_session  <code>module-attribute</code>","text":"<pre><code>prompt_session = PromptSession(\n    history=FileHistory(\n        global_config_dir / \"interactive_history.txt\"\n    )\n)\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgentConfig","title":"InteractiveAgentConfig  <code>dataclass</code>","text":"<pre><code>InteractiveAgentConfig(\n    system_template: str = \"You are a helpful assistant that can do anything.\",\n    instance_template: str = \"Your task: {{task}}. Please reply with a single shell command in triple backticks. To finish, the first line of the output of the shell command must be 'COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT'.\",\n    timeout_template: str = \"The last command &lt;command&gt;{{action['action']}}&lt;/command&gt; timed out and has been killed.\\nThe output of the command was:\\n &lt;output&gt;\\n{{output}}\\n&lt;/output&gt;\\nPlease try another command and make sure to avoid those requiring interactive input.\",\n    format_error_template: str = \"Please always provide EXACTLY ONE action in triple backticks.\",\n    action_observation_template: str = \"Observation: {{output}}\",\n    step_limit: int = 0,\n    cost_limit: float = 3.0,\n    mode: Literal[\"human\", \"confirm\", \"yolo\"] = \"confirm\",\n    whitelist_actions: list[str] = list(),\n    confirm_exit: bool = True,\n)\n</code></pre> <p>               Bases: <code>AgentConfig</code></p>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgentConfig.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['human', 'confirm', 'yolo'] = 'confirm'\n</code></pre> <p>Whether to confirm actions.</p>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgentConfig.whitelist_actions","title":"whitelist_actions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>whitelist_actions: list[str] = field(default_factory=list)\n</code></pre> <p>Never confirm actions that match these regular expressions.</p>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgentConfig.confirm_exit","title":"confirm_exit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>confirm_exit: bool = True\n</code></pre> <p>If the agent wants to finish, do we ask for confirmation from user?</p>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent","title":"InteractiveAgent","text":"<pre><code>InteractiveAgent(\n    *args, config_class=InteractiveAgentConfig, **kwargs\n)\n</code></pre> <p>               Bases: <code>DefaultAgent</code></p> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def __init__(self, *args, config_class=InteractiveAgentConfig, **kwargs):\n    super().__init__(*args, config_class=config_class, **kwargs)\n    self.cost_last_confirmed = 0.0\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.cost_last_confirmed","title":"cost_last_confirmed  <code>instance-attribute</code>","text":"<pre><code>cost_last_confirmed = 0.0\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.add_message","title":"add_message","text":"<pre><code>add_message(role: str, content: str)\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def add_message(self, role: str, content: str):\n    # Extend supermethod to print messages\n    super().add_message(role, content)\n    if role == \"assistant\":\n        console.print(\n            f\"\\n[red][bold]mini-swe-agent[/bold] (step [bold]{self.model.n_calls}[/bold], [bold]${self.model.cost:.2f}[/bold]):[/red]\\n\",\n            end=\"\",\n            highlight=False,\n        )\n    else:\n        console.print(f\"\\n[bold green]{role.capitalize()}[/bold green]:\\n\", end=\"\", highlight=False)\n    console.print(content, highlight=False, markup=False)\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.query","title":"query","text":"<pre><code>query() -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def query(self) -&gt; dict:\n    # Extend supermethod to handle human mode\n    if self.config.mode == \"human\":\n        match command := self._prompt_and_handle_special(\"[bold yellow]&gt;[/bold yellow] \"):\n            case \"/y\" | \"/c\":  # Just go to the super query, which queries the LM for the next action\n                pass\n            case _:\n                msg = {\"content\": f\"\\n```bash\\n{command}\\n```\"}\n                self.add_message(\"assistant\", msg[\"content\"])\n                return msg\n    try:\n        with console.status(\"Waiting for the LM to respond...\"):\n            return super().query()\n    except LimitsExceeded:\n        console.print(\n            f\"Limits exceeded. Limits: {self.config.step_limit} steps, ${self.config.cost_limit}.\\n\"\n            f\"Current spend: {self.model.n_calls} steps, ${self.model.cost:.2f}.\"\n        )\n        self.config.step_limit = int(input(\"New step limit: \"))\n        self.config.cost_limit = float(input(\"New cost limit: \"))\n        return super().query()\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.step","title":"step","text":"<pre><code>step() -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def step(self) -&gt; dict:\n    # Override the step method to handle user interruption\n    try:\n        console.print(Rule())\n        return super().step()\n    except KeyboardInterrupt:\n        # We always add a message about the interrupt and then just proceed to the next step\n        interruption_message = self._prompt_and_handle_special(\n            \"\\n\\n[bold yellow]Interrupted.[/bold yellow] \"\n            \"[green]Type a comment/command[/green] (/h for available commands)\"\n            \"\\n[bold yellow]&gt;[/bold yellow] \"\n        ).strip()\n        if not interruption_message or interruption_message in self._MODE_COMMANDS_MAPPING:\n            interruption_message = \"Temporary interruption caught.\"\n        raise NonTerminatingException(f\"Interrupted by user: {interruption_message}\")\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.execute_action","title":"execute_action","text":"<pre><code>execute_action(action: dict) -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def execute_action(self, action: dict) -&gt; dict:\n    # Override the execute_action method to handle user confirmation\n    if self.should_ask_confirmation(action[\"action\"]):\n        self.ask_confirmation()\n    return super().execute_action(action)\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.should_ask_confirmation","title":"should_ask_confirmation","text":"<pre><code>should_ask_confirmation(action: str) -&gt; bool\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def should_ask_confirmation(self, action: str) -&gt; bool:\n    return self.config.mode == \"confirm\" and not any(re.match(r, action) for r in self.config.whitelist_actions)\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.ask_confirmation","title":"ask_confirmation","text":"<pre><code>ask_confirmation() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def ask_confirmation(self) -&gt; None:\n    prompt = (\n        \"[bold yellow]Execute?[/bold yellow] [green][bold]Enter[/bold] to confirm[/green], \"\n        \"or [green]Type a comment/command[/green] (/h for available commands)\\n\"\n        \"[bold yellow]&gt;[/bold yellow] \"\n    )\n    match user_input := self._prompt_and_handle_special(prompt).strip():\n        case \"\" | \"/y\":\n            pass  # confirmed, do nothing\n        case \"/u\":  # Skip execution action and get back to query\n            raise NonTerminatingException(\"Command not executed. Switching to human mode\")\n        case _:\n            raise NonTerminatingException(\n                f\"Command not executed. The user rejected your command with the following message: {user_input}\"\n            )\n</code></pre>"},{"location":"reference/agents/interactive/#minisweagent.agents.interactive.InteractiveAgent.has_finished","title":"has_finished","text":"<pre><code>has_finished(output: dict[str, str])\n</code></pre> Source code in <code>src/minisweagent/agents/interactive.py</code> <pre><code>def has_finished(self, output: dict[str, str]):\n    try:\n        return super().has_finished(output)\n    except Submitted as e:\n        if self.config.confirm_exit:\n            console.print(\n                \"[bold green]Agent wants to finish.[/bold green] \"\n                \"[green]Type a comment to give it a new task or press enter to quit.\\n\"\n                \"[bold yellow]&gt;[/bold yellow] \",\n                end=\"\",\n            )\n            if new_task := self._prompt_and_handle_special(\"\").strip():\n                raise NonTerminatingException(f\"The user added a new task: {new_task}\")\n        raise e\n</code></pre>"},{"location":"reference/agents/textual/","title":"TextualAgent","text":"<p>See also</p> <ul> <li>This agent subclass builds on top of the default agent, make sure to read that first.</li> <li>This class powers the <code>mini</code> command line tool, see usage for more details.</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent","title":"minisweagent.agents.interactive_textual.TextualAgent","text":"<pre><code>TextualAgent(app: AgentApp, *args, **kwargs)\n</code></pre> <p>               Bases: <code>DefaultAgent</code></p> <p>Connects the DefaultAgent to the TextualApp.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def __init__(self, app: \"AgentApp\", *args, **kwargs):\n    \"\"\"Connects the DefaultAgent to the TextualApp.\"\"\"\n    self.app = app\n    super().__init__(*args, config_class=TextualAgentConfig, **kwargs)\n    self._current_action_from_human = False\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent.add_message","title":"add_message","text":"<pre><code>add_message(role: str, content: str)\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def add_message(self, role: str, content: str):\n    super().add_message(role, content)\n    if self.app.agent_state != \"UNINITIALIZED\":\n        self.app.call_from_thread(self.app.on_message_added)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent.query","title":"query","text":"<pre><code>query() -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def query(self) -&gt; dict:\n    if self.config.mode == \"human\":\n        human_input = self.app.input_container.request_input(\"Enter your command:\")\n        self._current_action_from_human = True\n        msg = {\"content\": f\"\\n```bash\\n{human_input}\\n```\"}\n        self.add_message(\"assistant\", msg[\"content\"])\n        return msg\n    self._current_action_from_human = False\n    return super().query()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent.run","title":"run","text":"<pre><code>run(task: str) -&gt; tuple[str, str]\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def run(self, task: str) -&gt; tuple[str, str]:\n    try:\n        exit_status, result = super().run(task)\n    except Exception as e:\n        result = str(e)\n        self.app.call_from_thread(self.app.action_quit)\n        print(traceback.format_exc())\n        return \"ERROR\", result\n    else:\n        self.app.call_from_thread(self.app.on_agent_finished, exit_status, result)\n    self.app.call_from_thread(self.app.action_quit)\n    return exit_status, result\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent.execute_action","title":"execute_action","text":"<pre><code>execute_action(action: dict) -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def execute_action(self, action: dict) -&gt; dict:\n    if self.config.mode == \"human\" and not self._current_action_from_human:  # threading, grrrrr\n        raise NonTerminatingException(\"Command not executed because user switched to manual mode.\")\n    if (\n        self.config.mode == \"confirm\"\n        and action[\"action\"].strip()\n        and not any(re.match(r, action[\"action\"]) for r in self.config.whitelist_actions)\n    ):\n        result = self.app.input_container.request_input(\"Press ENTER to confirm or provide rejection reason\")\n        if result:  # Non-empty string means rejection\n            raise NonTerminatingException(f\"Command not executed: {result}\")\n    return super().execute_action(action)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.TextualAgent.has_finished","title":"has_finished","text":"<pre><code>has_finished(output: dict[str, str])\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def has_finished(self, output: dict[str, str]):\n    try:\n        return super().has_finished(output)\n    except Submitted as e:\n        if self.config.confirm_exit:\n            if new_task := self.app.input_container.request_input(\n                \"[bold green]Agent wants to finish.[/bold green] \"\n                \"[green]Type a comment to give it a new task or press enter to quit.\\n\"\n            ).strip():\n                raise NonTerminatingException(f\"The user added a new task: {new_task}\")\n        raise e\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp","title":"minisweagent.agents.interactive_textual.AgentApp","text":"<pre><code>AgentApp(model, env, task: str, **kwargs)\n</code></pre> <p>               Bases: <code>App</code></p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def __init__(self, model, env, task: str, **kwargs):\n    css_path = os.environ.get(\"MSWEA_MINI_STYLE_PATH\", str(Path(__file__).parent.parent / \"config\" / \"mini.tcss\"))\n    self.__class__.CSS = Path(css_path).read_text()\n    super().__init__()\n    self.agent_state = \"UNINITIALIZED\"\n    self.agent_task = task\n    self.agent = TextualAgent(self, model=model, env=env, **kwargs)\n    self._i_step = 0\n    self.n_steps = 1\n    self.input_container = SmartInputContainer(self)\n    self.log_handler = AddLogEmitCallback(lambda record: self.call_from_thread(self.on_log_message_emitted, record))\n    logging.getLogger().addHandler(self.log_handler)\n    self._spinner = Spinner(\"dots\")\n    self.exit_status: str | None = None\n    self.result: str | None = None\n\n    self._vscroll = VerticalScroll()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.BINDINGS","title":"BINDINGS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BINDINGS = [\n    Binding(\n        \"right,l\",\n        \"next_step\",\n        \"Step++\",\n        tooltip=\"Show next step of the agent\",\n    ),\n    Binding(\n        \"left,h\",\n        \"previous_step\",\n        \"Step--\",\n        tooltip=\"Show previous step of the agent\",\n    ),\n    Binding(\n        \"0\",\n        \"first_step\",\n        \"Step=0\",\n        tooltip=\"Show first step of the agent\",\n        show=False,\n    ),\n    Binding(\n        \"$\",\n        \"last_step\",\n        \"Step=-1\",\n        tooltip=\"Show last step of the agent\",\n        show=False,\n    ),\n    Binding(\n        \"j,down\", \"scroll_down\", \"Scroll down\", show=False\n    ),\n    Binding(\"k,up\", \"scroll_up\", \"Scroll up\", show=False),\n    Binding(\n        \"q,ctrl+q\", \"quit\", \"Quit\", tooltip=\"Quit the agent\"\n    ),\n    Binding(\n        \"y,ctrl+y\",\n        \"yolo\",\n        \"YOLO mode\",\n        tooltip=\"Switch to YOLO Mode (LM actions will execute immediately)\",\n    ),\n    Binding(\n        \"c\",\n        \"confirm\",\n        \"CONFIRM mode\",\n        tooltip=\"Switch to Confirm Mode (LM proposes commands and you confirm/reject them)\",\n    ),\n    Binding(\n        \"u,ctrl+u\",\n        \"human\",\n        \"HUMAN mode\",\n        tooltip=\"Switch to Human Mode (you can now type commands directly)\",\n    ),\n    Binding(\n        \"f1,question_mark\",\n        \"toggle_help_panel\",\n        \"Help\",\n        tooltip=\"Show help\",\n    ),\n]\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.agent_state","title":"agent_state  <code>instance-attribute</code>","text":"<pre><code>agent_state = 'UNINITIALIZED'\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.agent_task","title":"agent_task  <code>instance-attribute</code>","text":"<pre><code>agent_task = task\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.agent","title":"agent  <code>instance-attribute</code>","text":"<pre><code>agent = TextualAgent(self, model=model, env=env, **kwargs)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.n_steps","title":"n_steps  <code>instance-attribute</code>","text":"<pre><code>n_steps = 1\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.input_container","title":"input_container  <code>instance-attribute</code>","text":"<pre><code>input_container = SmartInputContainer(self)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.log_handler","title":"log_handler  <code>instance-attribute</code>","text":"<pre><code>log_handler = AddLogEmitCallback(\n    lambda record: call_from_thread(\n        on_log_message_emitted, record\n    )\n)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.exit_status","title":"exit_status  <code>instance-attribute</code>","text":"<pre><code>exit_status: str | None = None\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.result","title":"result  <code>instance-attribute</code>","text":"<pre><code>result: str | None = None\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.i_step","title":"i_step  <code>property</code> <code>writable</code>","text":"<pre><code>i_step: int\n</code></pre> <p>Current step index.</p>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.compose","title":"compose","text":"<pre><code>compose() -&gt; ComposeResult\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    yield Header()\n    with Container(id=\"main\"):\n        with self._vscroll:\n            with Vertical(id=\"content\"):\n                pass\n            yield self.input_container\n    yield Footer()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.on_mount","title":"on_mount","text":"<pre><code>on_mount() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_mount(self) -&gt; None:\n    self.agent_state = \"RUNNING\"\n    self.update_content()\n    self.set_interval(1 / 8, self._update_headers)\n    threading.Thread(target=lambda: self.agent.run(self.agent_task), daemon=True).start()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.on_message_added","title":"on_message_added","text":"<pre><code>on_message_added() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_message_added(self) -&gt; None:\n    auto_follow = self.i_step == self.n_steps - 1 and self._vscroll.scroll_y &lt;= 1\n    self.n_steps = len(_messages_to_steps(self.agent.messages))\n    self.update_content()\n    if auto_follow:\n        self.action_last_step()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.on_log_message_emitted","title":"on_log_message_emitted","text":"<pre><code>on_log_message_emitted(record: LogRecord) -&gt; None\n</code></pre> <p>Handle log messages of warning level or higher by showing them as notifications.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_log_message_emitted(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"Handle log messages of warning level or higher by showing them as notifications.\"\"\"\n    if record.levelno &gt;= logging.WARNING:\n        self.notify(f\"[{record.levelname}] {record.getMessage()}\", severity=\"warning\")\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.on_unmount","title":"on_unmount","text":"<pre><code>on_unmount() -&gt; None\n</code></pre> <p>Clean up the log handler when the app shuts down.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_unmount(self) -&gt; None:\n    \"\"\"Clean up the log handler when the app shuts down.\"\"\"\n    if hasattr(self, \"log_handler\"):\n        logging.getLogger().removeHandler(self.log_handler)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.on_agent_finished","title":"on_agent_finished","text":"<pre><code>on_agent_finished(exit_status: str, result: str)\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_agent_finished(self, exit_status: str, result: str):\n    self.agent_state = \"STOPPED\"\n    self.notify(f\"Agent finished with status: {exit_status}\")\n    self.exit_status = exit_status\n    self.result = result\n    self.update_content()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.update_content","title":"update_content","text":"<pre><code>update_content() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def update_content(self) -&gt; None:\n    container = self.query_one(\"#content\", Vertical)\n    container.remove_children()\n    items = _messages_to_steps(self.agent.messages)\n\n    if not items:\n        container.mount(Static(\"Waiting for agent to start...\"))\n        return\n\n    for message in items[self.i_step]:\n        if isinstance(message[\"content\"], list):\n            content_str = \"\\n\".join([item[\"text\"] for item in message[\"content\"]])\n        else:\n            content_str = str(message[\"content\"])\n        message_container = Vertical(classes=\"message-container\")\n        container.mount(message_container)\n        role = message[\"role\"].replace(\"assistant\", \"mini-swe-agent\")\n        message_container.mount(Static(role.upper(), classes=\"message-header\"))\n        message_container.mount(Static(Text(content_str, no_wrap=False), classes=\"message-content\"))\n\n    if self.input_container.pending_prompt is not None:\n        self.agent_state = \"AWAITING_INPUT\"\n    self.input_container.display = self.input_container.pending_prompt is not None and self.i_step == len(items) - 1\n    if self.input_container.display:\n        self.input_container.on_focus()\n\n    self._update_headers()\n    self.refresh()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.get_system_commands","title":"get_system_commands","text":"<pre><code>get_system_commands(\n    screen: Screen,\n) -&gt; Iterable[SystemCommand]\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def get_system_commands(self, screen: Screen) -&gt; Iterable[SystemCommand]:\n    # Add to palette\n    yield from super().get_system_commands(screen)\n    for binding in self.BINDINGS:\n        description = f\"{binding.description} (shortcut {' OR '.join(binding.key.split(','))})\"  # type: ignore[attr-defined]\n        yield SystemCommand(description, binding.tooltip, binding.action)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_yolo","title":"action_yolo","text":"<pre><code>action_yolo()\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_yolo(self):\n    self.agent.config.mode = \"yolo\"\n    if self.input_container.pending_prompt is not None:\n        self.input_container._complete_input(\"\")  # accept\n    self.notify(\"YOLO mode enabled - LM actions will execute immediately\")\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_human","title":"action_human","text":"<pre><code>action_human()\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_human(self):\n    if self.agent.config.mode == \"confirm\" and self.input_container.pending_prompt is not None:\n        self.input_container._complete_input(\"User switched to manual mode, this command will be ignored\")\n    self.agent.config.mode = \"human\"\n    self.notify(\"Human mode enabled - you can now type commands directly\")\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_confirm","title":"action_confirm","text":"<pre><code>action_confirm()\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_confirm(self):\n    if self.agent.config.mode == \"human\" and self.input_container.pending_prompt is not None:\n        self.input_container._complete_input(\"\")  # just submit blank action\n    self.agent.config.mode = \"confirm\"\n    self.notify(\"Confirm mode enabled - LM proposes commands and you confirm/reject them\")\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_next_step","title":"action_next_step","text":"<pre><code>action_next_step() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_next_step(self) -&gt; None:\n    self.i_step += 1\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_previous_step","title":"action_previous_step","text":"<pre><code>action_previous_step() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_previous_step(self) -&gt; None:\n    self.i_step -= 1\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_first_step","title":"action_first_step","text":"<pre><code>action_first_step() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_first_step(self) -&gt; None:\n    self.i_step = 0\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_last_step","title":"action_last_step","text":"<pre><code>action_last_step() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_last_step(self) -&gt; None:\n    self.i_step = self.n_steps - 1\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_scroll_down","title":"action_scroll_down","text":"<pre><code>action_scroll_down() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_scroll_down(self) -&gt; None:\n    self._vscroll.scroll_to(y=self._vscroll.scroll_target_y + 15)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_scroll_up","title":"action_scroll_up","text":"<pre><code>action_scroll_up() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_scroll_up(self) -&gt; None:\n    self._vscroll.scroll_to(y=self._vscroll.scroll_target_y - 15)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AgentApp.action_toggle_help_panel","title":"action_toggle_help_panel","text":"<pre><code>action_toggle_help_panel() -&gt; None\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_toggle_help_panel(self) -&gt; None:\n    if self.query(\"HelpPanel\"):\n        self.action_hide_help_panel()\n    else:\n        self.action_show_help_panel()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer","title":"minisweagent.agents.interactive_textual.SmartInputContainer","text":"<pre><code>SmartInputContainer(app: AgentApp)\n</code></pre> <p>               Bases: <code>Container</code></p> <p>Smart input container supporting single-line and multi-line input modes.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def __init__(self, app: \"AgentApp\"):\n    \"\"\"Smart input container supporting single-line and multi-line input modes.\"\"\"\n    super().__init__(classes=\"smart-input-container\")\n    self._app = app\n    self._multiline_mode = False\n    self.can_focus = True\n    self.display = False\n\n    self.pending_prompt: str | None = None\n    self._input_event = threading.Event()\n    self._input_result: str | None = None\n\n    self._header_display = Static(id=\"input-header-display\", classes=\"message-header input-request-header\")\n    self._hint_text = Static(classes=\"hint-text\")\n    self._single_input = Input(placeholder=\"Type your input...\")\n    self._multi_input = TextArea(show_line_numbers=False, classes=\"multi-input\")\n    self._input_elements_container = Vertical(\n        self._header_display,\n        self._hint_text,\n        self._single_input,\n        self._multi_input,\n        classes=\"message-container\",\n    )\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.can_focus","title":"can_focus  <code>instance-attribute</code>","text":"<pre><code>can_focus = True\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.display","title":"display  <code>instance-attribute</code>","text":"<pre><code>display = False\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.pending_prompt","title":"pending_prompt  <code>instance-attribute</code>","text":"<pre><code>pending_prompt: str | None = None\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.compose","title":"compose","text":"<pre><code>compose() -&gt; ComposeResult\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    yield self._input_elements_container\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.on_mount","title":"on_mount","text":"<pre><code>on_mount() -&gt; None\n</code></pre> <p>Initialize the widget state.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Initialize the widget state.\"\"\"\n    self._multi_input.display = False\n    self._update_mode_display()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.on_focus","title":"on_focus","text":"<pre><code>on_focus() -&gt; None\n</code></pre> <p>Called when the container gains focus.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_focus(self) -&gt; None:\n    \"\"\"Called when the container gains focus.\"\"\"\n    if self._multiline_mode:\n        self._multi_input.focus()\n    else:\n        self._single_input.focus()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.request_input","title":"request_input","text":"<pre><code>request_input(prompt: str) -&gt; str\n</code></pre> <p>Request input from user. Returns input text (empty string if confirmed without reason).</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def request_input(self, prompt: str) -&gt; str:\n    \"\"\"Request input from user. Returns input text (empty string if confirmed without reason).\"\"\"\n    self._input_event.clear()\n    self._input_result = None\n    self.pending_prompt = prompt\n    self._header_display.update(prompt)\n    self._update_mode_display()\n    self._app.call_from_thread(self._app.update_content)\n    self._input_event.wait()\n    return self._input_result or \"\"\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.action_toggle_mode","title":"action_toggle_mode","text":"<pre><code>action_toggle_mode() -&gt; None\n</code></pre> <p>Switch from single-line to multi-line mode (one-way only).</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def action_toggle_mode(self) -&gt; None:\n    \"\"\"Switch from single-line to multi-line mode (one-way only).\"\"\"\n    if self.pending_prompt is None or self._multiline_mode:\n        return\n\n    self._multiline_mode = True\n    self._update_mode_display()\n    self.on_focus()\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.on_input_submitted","title":"on_input_submitted","text":"<pre><code>on_input_submitted(event: Submitted) -&gt; None\n</code></pre> <p>Handle single-line input submission.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle single-line input submission.\"\"\"\n    if not self._multiline_mode:\n        text = event.input.value.strip()\n        self._complete_input(text)\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.SmartInputContainer.on_key","title":"on_key","text":"<pre><code>on_key(event: Key) -&gt; None\n</code></pre> <p>Handle key events.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def on_key(self, event: Key) -&gt; None:\n    \"\"\"Handle key events.\"\"\"\n    if event.key == \"ctrl+t\" and not self._multiline_mode:\n        event.prevent_default()\n        self.action_toggle_mode()\n        return\n\n    if self._multiline_mode and event.key == \"ctrl+d\":\n        event.prevent_default()\n        self._complete_input(self._multi_input.text.strip())\n        return\n\n    if event.key == \"escape\":\n        event.prevent_default()\n        self.can_focus = False\n        self._app.set_focus(None)\n        return\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AddLogEmitCallback","title":"minisweagent.agents.interactive_textual.AddLogEmitCallback","text":"<pre><code>AddLogEmitCallback(callback)\n</code></pre> <p>               Bases: <code>Handler</code></p> <p>Custom log handler that forwards messages via callback.</p> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def __init__(self, callback):\n    \"\"\"Custom log handler that forwards messages via callback.\"\"\"\n    super().__init__()\n    self.callback = callback\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AddLogEmitCallback.callback","title":"callback  <code>instance-attribute</code>","text":"<pre><code>callback = callback\n</code></pre>"},{"location":"reference/agents/textual/#minisweagent.agents.interactive_textual.AddLogEmitCallback.emit","title":"emit","text":"<pre><code>emit(record: LogRecord)\n</code></pre> Source code in <code>src/minisweagent/agents/interactive_textual.py</code> <pre><code>def emit(self, record: logging.LogRecord):\n    self.callback(record)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/environments/docker/","title":"Docker","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker","title":"minisweagent.environments.docker","text":""},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig","title":"DockerEnvironmentConfig  <code>dataclass</code>","text":"<pre><code>DockerEnvironmentConfig(\n    image: str,\n    cwd: str = \"/\",\n    env: dict[str, str] = dict(),\n    forward_env: list[str] = list(),\n    timeout: int = 30,\n    executable: str = \"docker\",\n    run_args: list[str] = list(),\n    container_timeout: str = \"2h\",\n)\n</code></pre>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.image","title":"image  <code>instance-attribute</code>","text":"<pre><code>image: str\n</code></pre>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str = '/'\n</code></pre> <p>Working directory in which to execute commands.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>Environment variables to set in the container.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.forward_env","title":"forward_env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forward_env: list[str] = field(default_factory=list)\n</code></pre> <p>Environment variables to forward to the container. Variables are only forwarded if they are set in the host environment. In case of conflict with <code>env</code>, the <code>env</code> variables take precedence.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: int = 30\n</code></pre> <p>Timeout for executing commands in the container.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.executable","title":"executable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>executable: str = 'docker'\n</code></pre> <p>Path to the docker/container executable.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.run_args","title":"run_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_args: list[str] = field(default_factory=list)\n</code></pre> <p>Additional arguments to pass to the docker/container executable.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironmentConfig.container_timeout","title":"container_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>container_timeout: str = '2h'\n</code></pre> <p>Max duration to keep container running. Uses the same format as the sleep command.</p>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironment","title":"DockerEnvironment","text":"<pre><code>DockerEnvironment(\n    *,\n    config_class: type = DockerEnvironmentConfig,\n    **kwargs,\n)\n</code></pre> <p>This class executes bash commands in a Docker container using direct docker commands. See <code>DockerEnvironmentConfig</code> for keyword arguments.</p> Source code in <code>src/minisweagent/environments/docker.py</code> <pre><code>def __init__(self, *, config_class: type = DockerEnvironmentConfig, **kwargs):\n    \"\"\"This class executes bash commands in a Docker container using direct docker commands.\n    See `DockerEnvironmentConfig` for keyword arguments.\n    \"\"\"\n    self.container_id: str | None = None\n    self.config = config_class(**kwargs)\n    self._start_container()\n</code></pre>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironment.container_id","title":"container_id  <code>instance-attribute</code>","text":"<pre><code>container_id: str | None = None\n</code></pre>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironment.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config_class(**kwargs)\n</code></pre>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironment.execute","title":"execute","text":"<pre><code>execute(command: str, cwd: str = '') -&gt; dict[str, Any]\n</code></pre> <p>Execute a command in the Docker container and return the result as a dict.</p> Source code in <code>src/minisweagent/environments/docker.py</code> <pre><code>def execute(self, command: str, cwd: str = \"\") -&gt; dict[str, Any]:\n    \"\"\"Execute a command in the Docker container and return the result as a dict.\"\"\"\n    cwd = cwd or self.config.cwd\n    assert self.container_id, \"Container not started\"\n\n    cmd = [self.config.executable, \"exec\", \"-w\", cwd]\n    for key in self.config.forward_env:\n        if (value := os.getenv(key)) is not None:\n            cmd.extend([\"-e\", f\"{key}={value}\"])\n    for key, value in self.config.env.items():\n        cmd.extend([\"-e\", f\"{key}={value}\"])\n    cmd.extend([self.container_id, \"bash\", \"-lc\", command])\n\n    result = subprocess.run(\n        cmd,\n        text=True,\n        timeout=self.config.timeout,\n        encoding=\"utf-8\",\n        errors=\"replace\",\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n    )\n    return {\"output\": result.stdout, \"returncode\": result.returncode}\n</code></pre>"},{"location":"reference/environments/docker/#minisweagent.environments.docker.DockerEnvironment.cleanup","title":"cleanup","text":"<pre><code>cleanup()\n</code></pre> <p>Stop and remove the Docker container.</p> Source code in <code>src/minisweagent/environments/docker.py</code> <pre><code>def cleanup(self):\n    \"\"\"Stop and remove the Docker container.\"\"\"\n    if getattr(self, \"container_id\", None) is not None:  # if init fails early, container_id might not be set\n        print(f\"Stopping container {self.container_id}\")\n        cmd = f\"(timeout 60 {self.config.executable} stop {self.container_id} || {self.config.executable} rm -f {self.container_id}) &gt;/dev/null 2&gt;&amp;1 &amp;\"\n        subprocess.Popen(cmd, shell=True)\n</code></pre>"},{"location":"reference/environments/local/","title":"Local","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/environments/local/#minisweagent.environments.local","title":"minisweagent.environments.local","text":""},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironmentConfig","title":"LocalEnvironmentConfig  <code>dataclass</code>","text":"<pre><code>LocalEnvironmentConfig(\n    cwd: str = \"\",\n    env: dict[str, str] = dict(),\n    timeout: int = 30,\n)\n</code></pre>"},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironmentConfig.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str = ''\n</code></pre>"},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironmentConfig.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironmentConfig.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: int = 30\n</code></pre>"},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironment","title":"LocalEnvironment","text":"<pre><code>LocalEnvironment(\n    *, config_class: type = LocalEnvironmentConfig, **kwargs\n)\n</code></pre> <p>This class executes bash commands directly on the local machine.</p> Source code in <code>src/minisweagent/environments/local.py</code> <pre><code>def __init__(self, *, config_class: type = LocalEnvironmentConfig, **kwargs):\n    \"\"\"This class executes bash commands directly on the local machine.\"\"\"\n    self.config = config_class(**kwargs)\n</code></pre>"},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironment.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config_class(**kwargs)\n</code></pre>"},{"location":"reference/environments/local/#minisweagent.environments.local.LocalEnvironment.execute","title":"execute","text":"<pre><code>execute(command: str, cwd: str = '')\n</code></pre> <p>Execute a command in the local environment and return the result as a dict.</p> Source code in <code>src/minisweagent/environments/local.py</code> <pre><code>def execute(self, command: str, cwd: str = \"\"):\n    \"\"\"Execute a command in the local environment and return the result as a dict.\"\"\"\n    cwd = cwd or self.config.cwd or os.getcwd()\n    result = subprocess.run(\n        command,\n        shell=True,\n        text=True,\n        cwd=cwd,\n        env=os.environ | self.config.env,\n        timeout=self.config.timeout,\n        encoding=\"utf-8\",\n        errors=\"replace\",\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n    )\n    return {\"output\": result.stdout, \"returncode\": result.returncode}\n</code></pre>"},{"location":"reference/environments/swerex_docker/","title":"SWE-rex Docker","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker","title":"minisweagent.environments.extra.swerex_docker","text":""},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironmentConfig","title":"SwerexDockerEnvironmentConfig  <code>dataclass</code>","text":"<pre><code>SwerexDockerEnvironmentConfig(\n    image: str,\n    cwd: str = \"/\",\n    timeout: int = 30,\n    deployment_extra_kwargs: dict[str, Any] = dict(),\n)\n</code></pre>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironmentConfig.image","title":"image  <code>instance-attribute</code>","text":"<pre><code>image: str\n</code></pre>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironmentConfig.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str = '/'\n</code></pre> <p>Working directory in which to execute commands.</p>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironmentConfig.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: int = 30\n</code></pre> <p>Timeout for executing commands in the container.</p>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironmentConfig.deployment_extra_kwargs","title":"deployment_extra_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deployment_extra_kwargs: dict[str, Any] = field(\n    default_factory=dict\n)\n</code></pre> <p>Extra kwargs to pass to DockerDeployment.</p>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironment","title":"SwerexDockerEnvironment","text":"<pre><code>SwerexDockerEnvironment(**kwargs)\n</code></pre> <p>This class executes bash commands in a Docker container using SWE-ReX for sandboxing.</p> Source code in <code>src/minisweagent/environments/extra/swerex_docker.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"This class executes bash commands in a Docker container using SWE-ReX for sandboxing.\"\"\"\n    self.config = SwerexDockerEnvironmentConfig(**kwargs)\n    self.deployment = DockerDeployment(image=self.config.image, **self.config.deployment_extra_kwargs)\n    asyncio.run(self.deployment.start())\n</code></pre>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironment.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = SwerexDockerEnvironmentConfig(**kwargs)\n</code></pre>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironment.deployment","title":"deployment  <code>instance-attribute</code>","text":"<pre><code>deployment = DockerDeployment(\n    image=image, **(deployment_extra_kwargs)\n)\n</code></pre>"},{"location":"reference/environments/swerex_docker/#minisweagent.environments.extra.swerex_docker.SwerexDockerEnvironment.execute","title":"execute","text":"<pre><code>execute(command: str, cwd: str = '') -&gt; dict[str, Any]\n</code></pre> <p>Execute a command in the environment and return the raw output.</p> Source code in <code>src/minisweagent/environments/extra/swerex_docker.py</code> <pre><code>def execute(self, command: str, cwd: str = \"\") -&gt; dict[str, Any]:\n    \"\"\"Execute a command in the environment and return the raw output.\"\"\"\n    output = asyncio.run(\n        self.deployment.runtime.execute(\n            RexCommand(\n                command=command, shell=True, check=False, cwd=cwd or self.config.cwd, timeout=self.config.timeout\n            )\n        )\n    )\n    return {\n        \"output\": f\"&lt;stdout&gt;\\n{output.stdout}&lt;/stdout&gt;\\n&lt;stderr&gt;\\n{output.stderr}&lt;/stderr&gt;\",\n        \"returncode\": output.exit_code,\n    }\n</code></pre>"},{"location":"reference/models/anthropic/","title":"Anthropic","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/models/anthropic/#minisweagent.models.anthropic","title":"minisweagent.models.anthropic","text":""},{"location":"reference/models/anthropic/#minisweagent.models.anthropic.AnthropicModel","title":"AnthropicModel","text":"<pre><code>AnthropicModel(**kwargs)\n</code></pre> <p>               Bases: <code>LitellmModel</code></p> <p>For the use of anthropic models, we need to add explicit cache control marks to the messages or we lose out on the benefits of the cache. Because break points are limited per key, we also need to rotate between different keys if running with multiple agents in parallel threads.</p> Source code in <code>src/minisweagent/models/litellm_model.py</code> <pre><code>def __init__(self, **kwargs):\n    self.config = LitellmModelConfig(**kwargs)\n    self.cost = 0.0\n    self.n_calls = 0\n    if self.config.litellm_model_registry and Path(self.config.litellm_model_registry).is_file():\n        litellm.utils.register_model(json.loads(Path(self.config.litellm_model_registry).read_text()))\n</code></pre>"},{"location":"reference/models/anthropic/#minisweagent.models.anthropic.AnthropicModel.query","title":"query","text":"<pre><code>query(messages: list[dict], **kwargs) -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/models/anthropic.py</code> <pre><code>def query(self, messages: list[dict], **kwargs) -&gt; dict:\n    api_key = None\n    if rotating_keys := os.getenv(\"ANTHROPIC_API_KEYS\"):\n        api_key = get_key_per_thread(rotating_keys.split(\"::\"))\n    return super().query(set_cache_control(messages), api_key=api_key, **kwargs)\n</code></pre>"},{"location":"reference/models/litellm/","title":"Litellm Model","text":"<p>Guides</p> <ul> <li>Setting up most models is covered in the quickstart guide.</li> <li>If you want to use local models, please check this guide.</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model","title":"minisweagent.models.litellm_model","text":""},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('litellm_model')\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModelConfig","title":"LitellmModelConfig  <code>dataclass</code>","text":"<pre><code>LitellmModelConfig(\n    model_name: str,\n    model_kwargs: dict[str, Any] = dict(),\n    litellm_model_registry: Path | str | None = getenv(\n        \"LITELLM_MODEL_REGISTRY_PATH\"\n    ),\n)\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModelConfig.model_name","title":"model_name  <code>instance-attribute</code>","text":"<pre><code>model_name: str\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModelConfig.model_kwargs","title":"model_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_kwargs: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModelConfig.litellm_model_registry","title":"litellm_model_registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>litellm_model_registry: Path | str | None = getenv(\n    \"LITELLM_MODEL_REGISTRY_PATH\"\n)\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModel","title":"LitellmModel","text":"<pre><code>LitellmModel(**kwargs)\n</code></pre> Source code in <code>src/minisweagent/models/litellm_model.py</code> <pre><code>def __init__(self, **kwargs):\n    self.config = LitellmModelConfig(**kwargs)\n    self.cost = 0.0\n    self.n_calls = 0\n    if self.config.litellm_model_registry and Path(self.config.litellm_model_registry).is_file():\n        litellm.utils.register_model(json.loads(Path(self.config.litellm_model_registry).read_text()))\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModel.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = LitellmModelConfig(**kwargs)\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModel.cost","title":"cost  <code>instance-attribute</code>","text":"<pre><code>cost = 0.0\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModel.n_calls","title":"n_calls  <code>instance-attribute</code>","text":"<pre><code>n_calls = 0\n</code></pre>"},{"location":"reference/models/litellm/#minisweagent.models.litellm_model.LitellmModel.query","title":"query","text":"<pre><code>query(messages: list[dict[str, str]], **kwargs) -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/models/litellm_model.py</code> <pre><code>def query(self, messages: list[dict[str, str]], **kwargs) -&gt; dict:\n    response = self._query(messages, **kwargs)\n    # cost = litellm.cost_calculator.completion_cost(response)  # \u30b3\u30b9\u30c8\u8a08\u7b97\u3092\u7121\u52b9\u5316\n    self.n_calls += 1\n    # self.cost += cost  # \u30b3\u30b9\u30c8\u8ffd\u52a0\u3092\u7121\u52b9\u5316\n    # GLOBAL_MODEL_STATS.add(cost)  # \u30b0\u30ed\u30fc\u30d0\u30eb\u7d71\u8a08\u3078\u306e\u8ffd\u52a0\u3092\u7121\u52b9\u5316\n    GLOBAL_MODEL_STATS.add(0)  # \u30b3\u30b9\u30c80\u3067\u8ffd\u52a0\uff08\u547c\u3073\u51fa\u3057\u56de\u6570\u306e\u307f\u30ab\u30a6\u30f3\u30c8\uff09\n    return {\n        \"content\": response.choices[0].message.content or \"\",  # type: ignore\n    }\n</code></pre>"},{"location":"reference/models/test_models/","title":"Test Models","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/models/test_models/#minisweagent.models.test_models","title":"minisweagent.models.test_models","text":""},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModelConfig","title":"DeterministicModelConfig  <code>dataclass</code>","text":"<pre><code>DeterministicModelConfig(\n    outputs: list[str],\n    model_name: str = \"deterministic\",\n    cost_per_call: float = 1.0,\n)\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModelConfig.outputs","title":"outputs  <code>instance-attribute</code>","text":"<pre><code>outputs: list[str]\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModelConfig.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name: str = 'deterministic'\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModelConfig.cost_per_call","title":"cost_per_call  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cost_per_call: float = 1.0\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModel","title":"DeterministicModel","text":"<pre><code>DeterministicModel(**kwargs)\n</code></pre> <p>Initialize with a list of outputs to return in sequence.</p> Source code in <code>src/minisweagent/models/test_models.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    Initialize with a list of outputs to return in sequence.\n    \"\"\"\n    self.config = DeterministicModelConfig(**kwargs)\n    self.current_index = -1\n    self.cost = 0.0\n    self.n_calls = 0\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModel.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = DeterministicModelConfig(**kwargs)\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModel.current_index","title":"current_index  <code>instance-attribute</code>","text":"<pre><code>current_index = -1\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModel.cost","title":"cost  <code>instance-attribute</code>","text":"<pre><code>cost = 0.0\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModel.n_calls","title":"n_calls  <code>instance-attribute</code>","text":"<pre><code>n_calls = 0\n</code></pre>"},{"location":"reference/models/test_models/#minisweagent.models.test_models.DeterministicModel.query","title":"query","text":"<pre><code>query(messages: list[dict[str, str]], **kwargs) -&gt; dict\n</code></pre> Source code in <code>src/minisweagent/models/test_models.py</code> <pre><code>def query(self, messages: list[dict[str, str]], **kwargs) -&gt; dict:\n    self.current_index += 1\n    output = self.config.outputs[self.current_index]\n    if \"/sleep\" in output:\n        print(\"SLEEPING\")\n        time.sleep(float(output.split(\"/sleep\")[1]))\n        return self.query(messages, **kwargs)\n    if \"/warning\" in output:\n        logging.warning(output.split(\"/warning\")[1])\n        return self.query(messages, **kwargs)\n    self.n_calls += 1\n    self.cost += self.config.cost_per_call\n    GLOBAL_MODEL_STATS.add(self.config.cost_per_call)\n    return {\"content\": output}\n</code></pre>"},{"location":"reference/models/utils/","title":"Model Utilities","text":"<p>Convenience functions for selecting and configuring models.</p> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/models/utils/#minisweagent.models.get_model","title":"minisweagent.models.get_model","text":"<pre><code>get_model(\n    input_model_name: str | None = None,\n    config: dict | None = None,\n) -&gt; Model\n</code></pre> <p>Get an initialized model object from any kind of user input or settings.</p> Source code in <code>src/minisweagent/models/__init__.py</code> <pre><code>def get_model(input_model_name: str | None = None, config: dict | None = None) -&gt; Model:\n    \"\"\"Get an initialized model object from any kind of user input or settings.\"\"\"\n    resolved_model_name = get_model_name(input_model_name, config)\n    if config is None:\n        config = {}\n    config = copy.deepcopy(config)\n    config[\"model_name\"] = resolved_model_name\n\n    # API key resolution (from env -&gt; config -&gt; None)\n    if \"model_kwargs\" not in config:\n        config[\"model_kwargs\"] = {}\n    if from_env := os.getenv(\"MSWEA_MODEL_API_KEY\"):\n        config[\"model_kwargs\"][\"api_key\"] = from_env\n    return get_model_class(resolved_model_name)(**config)\n</code></pre>"},{"location":"reference/models/utils/#minisweagent.models.get_model_name","title":"minisweagent.models.get_model_name","text":"<pre><code>get_model_name(\n    input_model_name: str | None = None,\n    config: dict | None = None,\n) -&gt; str\n</code></pre> <p>Get a model name from any kind of user input or settings.</p> Source code in <code>src/minisweagent/models/__init__.py</code> <pre><code>def get_model_name(input_model_name: str | None = None, config: dict | None = None) -&gt; str:\n    \"\"\"Get a model name from any kind of user input or settings.\"\"\"\n    if config is None:\n        config = {}\n    if input_model_name:\n        return input_model_name\n    if from_env := os.getenv(\"MSWEA_MODEL_NAME\"):\n        return from_env\n    if from_config := config.get(\"model_name\"):\n        return from_config\n    raise ValueError(\"No default model set. Please run `mini-extra config setup` to set one.\")\n</code></pre>"},{"location":"reference/models/utils/#minisweagent.models.get_model_class","title":"minisweagent.models.get_model_class","text":"<pre><code>get_model_class(model_name: str) -&gt; type\n</code></pre> <p>Select the best model class for a given model name.</p> Source code in <code>src/minisweagent/models/__init__.py</code> <pre><code>def get_model_class(model_name: str) -&gt; type:\n    \"\"\"Select the best model class for a given model name.\"\"\"\n    if any(s in model_name.lower() for s in [\"anthropic\", \"sonnet\", \"opus\", \"claude\"]):\n        from minisweagent.models.anthropic import AnthropicModel\n\n        return AnthropicModel\n    from minisweagent.models.litellm_model import LitellmModel\n\n    return LitellmModel\n</code></pre>"},{"location":"reference/run/github_issue/","title":"GitHub Issue","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/run/github_issue/#minisweagent.run.github_issue","title":"minisweagent.run.github_issue","text":""},{"location":"reference/run/github_issue/#minisweagent.run.github_issue.DEFAULT_CONFIG","title":"DEFAULT_CONFIG  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CONFIG = Path(\n    getenv(\n        \"MSWEA_GITHUB_CONFIG_PATH\",\n        builtin_config_dir / \"github_issue.yaml\",\n    )\n)\n</code></pre>"},{"location":"reference/run/github_issue/#minisweagent.run.github_issue.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = Console(highlight=False)\n</code></pre>"},{"location":"reference/run/github_issue/#minisweagent.run.github_issue.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(rich_markup_mode='rich', add_completion=False)\n</code></pre>"},{"location":"reference/run/github_issue/#minisweagent.run.github_issue.fetch_github_issue","title":"fetch_github_issue","text":"<pre><code>fetch_github_issue(issue_url: str) -&gt; str\n</code></pre> <p>Fetch GitHub issue text from the URL.</p> Source code in <code>src/minisweagent/run/github_issue.py</code> <pre><code>def fetch_github_issue(issue_url: str) -&gt; str:\n    \"\"\"Fetch GitHub issue text from the URL.\"\"\"\n    # Convert GitHub issue URL to API URL\n    api_url = issue_url.replace(\"github.com\", \"api.github.com/repos\").replace(\"/issues/\", \"/issues/\")\n\n    headers = {}\n    if github_token := os.getenv(\"GITHUB_TOKEN\"):\n        headers[\"Authorization\"] = f\"token {github_token}\"\n\n    response = requests.get(api_url, headers=headers)\n    issue_data = response.json()\n\n    title = issue_data[\"title\"]\n    body = issue_data[\"body\"] or \"\"\n\n    return f\"GitHub Issue: {title}\\n\\n{body}\"\n</code></pre>"},{"location":"reference/run/github_issue/#minisweagent.run.github_issue.main","title":"main","text":"<pre><code>main(\n    issue_url: str = Option(\n        prompt=\"Enter GitHub issue URL\",\n        help=\"GitHub issue URL\",\n    ),\n    config: Path = Option(\n        DEFAULT_CONFIG,\n        \"-c\",\n        \"--config\",\n        help=\"Path to config file\",\n    ),\n    model: str | None = Option(\n        None, \"-m\", \"--model\", help=\"Model to use\"\n    ),\n    yolo: bool = Option(\n        False,\n        \"-y\",\n        \"--yolo\",\n        help=\"Run without confirmation\",\n    ),\n) -&gt; InteractiveAgent\n</code></pre> <p>Run mini-SWE-agent on a GitHub issue</p> Source code in <code>src/minisweagent/run/github_issue.py</code> <pre><code>@app.command()\ndef main(\n    issue_url: str = typer.Option(prompt=\"Enter GitHub issue URL\", help=\"GitHub issue URL\"),\n    config: Path = typer.Option(DEFAULT_CONFIG, \"-c\", \"--config\", help=\"Path to config file\"),\n    model: str | None = typer.Option(None, \"-m\", \"--model\", help=\"Model to use\"),\n    yolo: bool = typer.Option(False, \"-y\", \"--yolo\", help=\"Run without confirmation\"),\n) -&gt; InteractiveAgent:\n    \"\"\"Run mini-SWE-agent on a GitHub issue\"\"\"\n    configure_if_first_time()\n\n    _config = yaml.safe_load(get_config_path(config).read_text())\n    _agent_config = _config.get(\"agent\", {})\n    if yolo:\n        _agent_config[\"mode\"] = \"yolo\"\n\n    task = fetch_github_issue(issue_url)\n\n    agent = InteractiveAgent(\n        get_model(model, _config.get(\"model\", {})),\n        DockerEnvironment(**_config.get(\"environment\", {})),\n        **_agent_config,\n    )\n\n    repo_url = issue_url.split(\"/issues/\")[0]\n    if github_token := os.getenv(\"GITHUB_TOKEN\"):\n        repo_url = repo_url.replace(\"https://github.com/\", f\"https://{github_token}@github.com/\") + \".git\"\n\n    agent.env.execute(f\"git clone {repo_url} /testbed\", cwd=\"/\")\n\n    exit_status, result = None, None\n    try:\n        exit_status, result = agent.run(task)\n    except KeyboardInterrupt:\n        console.print(\"\\n[bold red]KeyboardInterrupt -- goodbye[/bold red]\")\n    finally:\n        save_traj(agent, Path(\"traj.json\"), exit_status=exit_status, result=result)\n    return agent\n</code></pre>"},{"location":"reference/run/hello_world/","title":"Hello World","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/run/hello_world/#minisweagent.run.hello_world","title":"minisweagent.run.hello_world","text":""},{"location":"reference/run/hello_world/#minisweagent.run.hello_world.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer()\n</code></pre>"},{"location":"reference/run/hello_world/#minisweagent.run.hello_world.main","title":"main","text":"<pre><code>main(\n    task: str = Option(\n        ...,\n        \"-t\",\n        \"--task\",\n        help=\"Task/problem statement\",\n        show_default=False,\n        prompt=True,\n    ),\n    model_name: str = Option(\n        getenv(\"MSWEA_MODEL_NAME\"),\n        \"-m\",\n        \"--model\",\n        help=\"Model name (defaults to MSWEA_MODEL_NAME env var)\",\n        prompt=\"What model do you want to use?\",\n    ),\n) -&gt; DefaultAgent\n</code></pre> Source code in <code>src/minisweagent/run/hello_world.py</code> <pre><code>@app.command()\ndef main(\n    task: str = typer.Option(..., \"-t\", \"--task\", help=\"Task/problem statement\", show_default=False, prompt=True),\n    model_name: str = typer.Option(\n        os.getenv(\"MSWEA_MODEL_NAME\"),\n        \"-m\",\n        \"--model\",\n        help=\"Model name (defaults to MSWEA_MODEL_NAME env var)\",\n        prompt=\"What model do you want to use?\",\n    ),\n) -&gt; DefaultAgent:\n    agent = DefaultAgent(\n        LitellmModel(model_name=model_name),\n        LocalEnvironment(),\n        **yaml.safe_load(Path(package_dir / \"config\" / \"default.yaml\").read_text())[\"agent\"],\n    )\n    agent.run(task)\n    return agent\n</code></pre>"},{"location":"reference/run/mini/","title":"Local","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/run/mini/#minisweagent.run.mini","title":"minisweagent.run.mini","text":"<p>Run mini-SWE-agent in your local environment. This is the default executable <code>mini</code>.</p>"},{"location":"reference/run/mini/#minisweagent.run.mini.DEFAULT_CONFIG","title":"DEFAULT_CONFIG  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CONFIG = Path(\n    getenv(\n        \"MSWEA_MINI_CONFIG_PATH\",\n        builtin_config_dir / \"mini.yaml\",\n    )\n)\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.DEFAULT_OUTPUT","title":"DEFAULT_OUTPUT  <code>module-attribute</code>","text":"<pre><code>DEFAULT_OUTPUT = (\n    global_config_dir / \"last_mini_run.traj.json\"\n)\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = Console(highlight=False)\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(rich_markup_mode='rich')\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.prompt_session","title":"prompt_session  <code>module-attribute</code>","text":"<pre><code>prompt_session = PromptSession(\n    history=FileHistory(\n        global_config_dir / \"mini_task_history.txt\"\n    )\n)\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.run_interactive","title":"run_interactive","text":"<pre><code>run_interactive(\n    model: Model,\n    env: Environment,\n    agent_config: dict,\n    task: str,\n    output: Path | None = None,\n) -&gt; Any\n</code></pre> Source code in <code>src/minisweagent/run/mini.py</code> <pre><code>def run_interactive(model: Model, env: Environment, agent_config: dict, task: str, output: Path | None = None) -&gt; Any:\n    agent = InteractiveAgent(\n        model,\n        env,\n        **agent_config,\n    )\n\n    exit_status, result = None, None\n    try:\n        exit_status, result = agent.run(task)\n    finally:\n        if output:\n            save_traj(agent, output, exit_status=exit_status, result=result)\n    return agent\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.run_textual","title":"run_textual","text":"<pre><code>run_textual(\n    model: Model,\n    env: Environment,\n    agent_config: dict,\n    task: str,\n    output: Path | None = None,\n) -&gt; Any\n</code></pre> Source code in <code>src/minisweagent/run/mini.py</code> <pre><code>def run_textual(model: Model, env: Environment, agent_config: dict, task: str, output: Path | None = None) -&gt; Any:\n    agent_app = AgentApp(\n        model,\n        env,\n        task,\n        **agent_config,\n    )\n    try:\n        agent_app.run()\n    finally:\n        if output:\n            save_traj(agent_app.agent, output, exit_status=agent_app.exit_status, result=agent_app.result)\n</code></pre>"},{"location":"reference/run/mini/#minisweagent.run.mini.main","title":"main","text":"<pre><code>main(\n    visual: bool = Option(\n        False,\n        \"-v\",\n        \"--visual\",\n        help=\"Toggle (pager-style) UI (Textual) depending on the MSWEA_VISUAL_MODE_DEFAULT environment setting\",\n    ),\n    model_name: str | None = Option(\n        None, \"-m\", \"--model\", help=\"Model to use\"\n    ),\n    task: str | None = Option(\n        None,\n        \"-t\",\n        \"--task\",\n        help=\"Task/problem statement\",\n        show_default=False,\n    ),\n    yolo: bool = Option(\n        False,\n        \"-y\",\n        \"--yolo\",\n        help=\"Run without confirmation\",\n    ),\n    cost_limit: float | None = Option(\n        None,\n        \"-l\",\n        \"--cost-limit\",\n        help=\"Cost limit. Set to 0 to disable.\",\n    ),\n    config_spec: Path = Option(\n        DEFAULT_CONFIG,\n        \"-c\",\n        \"--config\",\n        help=\"Path to config file\",\n    ),\n    output: Path | None = Option(\n        DEFAULT_OUTPUT,\n        \"-o\",\n        \"--output\",\n        help=\"Output trajectory file\",\n    ),\n    exit_immediately: bool = Option(\n        False,\n        \"--exit-immediately\",\n        help=\"Exit immediately when the agent wants to finish instead of prompting.\",\n    ),\n) -&gt; Any\n</code></pre> Source code in <code>src/minisweagent/run/mini.py</code> <pre><code>@app.command(help=_HELP_TEXT)\ndef main(\n    visual: bool = typer.Option(\n        False,\n        \"-v\",\n        \"--visual\",\n        help=\"Toggle (pager-style) UI (Textual) depending on the MSWEA_VISUAL_MODE_DEFAULT environment setting\",\n    ),\n    model_name: str | None = typer.Option(\n        None,\n        \"-m\",\n        \"--model\",\n        help=\"Model to use\",\n    ),\n    task: str | None = typer.Option(None, \"-t\", \"--task\", help=\"Task/problem statement\", show_default=False),\n    yolo: bool = typer.Option(False, \"-y\", \"--yolo\", help=\"Run without confirmation\"),\n    cost_limit: float | None = typer.Option(None, \"-l\", \"--cost-limit\", help=\"Cost limit. Set to 0 to disable.\"),\n    config_spec: Path = typer.Option(DEFAULT_CONFIG, \"-c\", \"--config\", help=\"Path to config file\"),\n    output: Path | None = typer.Option(DEFAULT_OUTPUT, \"-o\", \"--output\", help=\"Output trajectory file\"),\n    exit_immediately: bool = typer.Option(\n        False, \"--exit-immediately\", help=\"Exit immediately when the agent wants to finish instead of prompting.\"\n    ),\n) -&gt; Any:\n    configure_if_first_time()\n    config = yaml.safe_load(get_config_path(config_spec).read_text())\n\n    if not task:\n        console.print(\"[bold yellow]What do you want to do?\")\n        task = prompt_session.prompt(\n            \"\",\n            multiline=True,\n            bottom_toolbar=HTML(\n                \"Submit task: &lt;b fg='yellow' bg='black'&gt;Esc+Enter&lt;/b&gt; | \"\n                \"Navigate history: &lt;b fg='yellow' bg='black'&gt;Arrow Up/Down&lt;/b&gt; | \"\n                \"Search history: &lt;b fg='yellow' bg='black'&gt;Ctrl+R&lt;/b&gt;\"\n            ),\n        )\n        console.print(\"[bold green]Got that, thanks![/bold green]\")\n\n    config[\"agent\"][\"mode\"] = \"confirm\" if not yolo else \"yolo\"\n    if cost_limit:\n        config[\"agent\"][\"cost_limit\"] = cost_limit\n    if exit_immediately:\n        config[\"agent\"][\"confirm_exit\"] = False\n    model = get_model(model_name, config.get(\"model\", {}))\n    env = LocalEnvironment(**config.get(\"env\", {}))\n\n    # Both visual flag and the MSWEA_VISUAL_MODE_DEFAULT flip the mode, so it's essentially a XOR\n    if visual == (os.getenv(\"MSWEA_VISUAL_MODE_DEFAULT\", \"false\") == \"false\"):\n        return run_textual(model, env, config[\"agent\"], task, output)  # type: ignore[arg-type]\n    else:\n        return run_interactive(model, env, config[\"agent\"], task, output)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/run/swebench/","title":"SWE-bench","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench","title":"minisweagent.run.extra.swebench","text":"<p>Run mini-SWE-agent on SWE-bench instances in batch mode.</p>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(rich_markup_mode='rich', add_completion=False)\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.DATASET_MAPPING","title":"DATASET_MAPPING  <code>module-attribute</code>","text":"<pre><code>DATASET_MAPPING = {\n    \"full\": \"princeton-nlp/SWE-Bench\",\n    \"verified\": \"princeton-nlp/SWE-Bench_Verified\",\n    \"lite\": \"princeton-nlp/SWE-Bench_Lite\",\n    \"multimodal\": \"princeton-nlp/SWE-Bench_Multimodal\",\n    \"multilingual\": \"swe-bench/SWE-Bench_Multilingual\",\n    \"smith\": \"SWE-bench/SWE-smith\",\n    \"_test\": \"klieret/swe-bench-dummy-test-dataset\",\n}\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.ProgressTrackingAgent","title":"ProgressTrackingAgent","text":"<pre><code>ProgressTrackingAgent(\n    *args,\n    progress_manager: RunBatchProgressManager,\n    instance_id: str = \"\",\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DefaultAgent</code></p> <p>Simple wrapper around DefaultAgent that provides progress updates.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def __init__(self, *args, progress_manager: RunBatchProgressManager, instance_id: str = \"\", **kwargs):\n    super().__init__(*args, **kwargs)\n    self.progress_manager: RunBatchProgressManager = progress_manager\n    self.instance_id = instance_id\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.ProgressTrackingAgent.progress_manager","title":"progress_manager  <code>instance-attribute</code>","text":"<pre><code>progress_manager: RunBatchProgressManager = progress_manager\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.ProgressTrackingAgent.instance_id","title":"instance_id  <code>instance-attribute</code>","text":"<pre><code>instance_id = instance_id\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.ProgressTrackingAgent.step","title":"step","text":"<pre><code>step() -&gt; dict\n</code></pre> <p>Override step to provide progress updates.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def step(self) -&gt; dict:\n    \"\"\"Override step to provide progress updates.\"\"\"\n    self.progress_manager.update_instance_status(\n        self.instance_id, f\"Step {self.model.n_calls + 1:3d} (${self.model.cost:.2f})\"\n    )\n    return super().step()\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.get_swebench_docker_image_name","title":"get_swebench_docker_image_name","text":"<pre><code>get_swebench_docker_image_name(instance: dict) -&gt; str\n</code></pre> <p>Get the image name for a SWEBench instance.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def get_swebench_docker_image_name(instance: dict) -&gt; str:\n    \"\"\"Get the image name for a SWEBench instance.\"\"\"\n    image_name = instance.get(\"image_name\", None)\n    if image_name is None:\n        # Docker doesn't allow double underscore, so we replace them with a magic token\n        iid = instance[\"instance_id\"]\n        id_docker_compatible = iid.replace(\"__\", \"_1776_\")\n        image_name = f\"swebench/sweb.eval.x86_64.{id_docker_compatible}:latest\".lower()\n    return image_name\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.update_preds_file","title":"update_preds_file","text":"<pre><code>update_preds_file(\n    output_path: Path,\n    instance_id: str,\n    model_name: str,\n    result: str,\n)\n</code></pre> <p>Update the output JSON file with results from a single instance.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def update_preds_file(output_path: Path, instance_id: str, model_name: str, result: str):\n    \"\"\"Update the output JSON file with results from a single instance.\"\"\"\n    with _OUTPUT_FILE_LOCK:\n        output_data = {}\n        if output_path.exists():\n            output_data = json.loads(output_path.read_text())\n        output_data[instance_id] = {\n            \"model_name_or_path\": model_name,\n            \"instance_id\": instance_id,\n            \"model_patch\": result,\n        }\n        output_path.write_text(json.dumps(output_data, indent=2))\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.remove_from_preds_file","title":"remove_from_preds_file","text":"<pre><code>remove_from_preds_file(output_path: Path, instance_id: str)\n</code></pre> <p>Remove an instance from the predictions file.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def remove_from_preds_file(output_path: Path, instance_id: str):\n    \"\"\"Remove an instance from the predictions file.\"\"\"\n    if not output_path.exists():\n        return\n    with _OUTPUT_FILE_LOCK:\n        output_data = json.loads(output_path.read_text())\n        if instance_id in output_data:\n            del output_data[instance_id]\n            output_path.write_text(json.dumps(output_data, indent=2))\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.process_instance","title":"process_instance","text":"<pre><code>process_instance(\n    instance: dict,\n    output_dir: Path,\n    model_name: str | None,\n    config_path: str | Path,\n    progress_manager: RunBatchProgressManager,\n) -&gt; None\n</code></pre> <p>Process a single SWEBench instance.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def process_instance(\n    instance: dict,\n    output_dir: Path,\n    model_name: str | None,\n    config_path: str | Path,\n    progress_manager: RunBatchProgressManager,\n) -&gt; None:\n    \"\"\"Process a single SWEBench instance.\"\"\"\n    instance_id = instance[\"instance_id\"]\n    instance_dir = output_dir / instance_id\n    # avoid inconsistent state if something here fails and there's leftover previous files\n    remove_from_preds_file(output_dir / \"preds.json\", instance_id)\n    (instance_dir / f\"{instance_id}.traj.json\").unlink(missing_ok=True)\n\n    image_name = get_swebench_docker_image_name(instance)\n    config = yaml.safe_load(get_config_path(config_path).read_text())\n    model = get_model(model_name, config=config.get(\"model\", {}))\n    task = instance[\"problem_statement\"]\n\n    progress_manager.on_instance_start(instance_id)\n    progress_manager.update_instance_status(instance_id, \"Pulling/starting docker\")\n\n    agent = None\n    extra_info = None\n\n    try:\n        env = DockerEnvironment(**(config.get(\"environment\", {}) | {\"image\": image_name}))\n        agent = ProgressTrackingAgent(\n            model,\n            env,\n            progress_manager=progress_manager,\n            instance_id=instance_id,\n            **config.get(\"agent\", {}),\n        )\n        exit_status, result = agent.run(task)\n    except Exception as e:\n        print(f\"Error processing instance {instance_id}: {e}\\n{traceback.format_exc()}\")\n        exit_status, result = type(e).__name__, str(e)\n        extra_info = {\"traceback\": traceback.format_exc()}\n    finally:\n        save_traj(\n            agent,\n            instance_dir / f\"{instance_id}.traj.json\",\n            exit_status=exit_status,\n            result=result,\n            extra_info=extra_info,\n            instance_id=instance_id,\n        )\n        update_preds_file(output_dir / \"preds.json\", instance_id, model.config.model_name, result)\n        progress_manager.on_instance_end(instance_id, exit_status)\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.filter_instances","title":"filter_instances","text":"<pre><code>filter_instances(\n    instances: list[dict],\n    *,\n    filter_spec: str,\n    slice_spec: str = \"\",\n    shuffle: bool = False,\n) -&gt; list[dict]\n</code></pre> <p>Filter and slice a list of SWEBench instances.</p> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>def filter_instances(\n    instances: list[dict], *, filter_spec: str, slice_spec: str = \"\", shuffle: bool = False\n) -&gt; list[dict]:\n    \"\"\"Filter and slice a list of SWEBench instances.\"\"\"\n    if shuffle:\n        instances = sorted(instances.copy(), key=lambda x: x[\"instance_id\"])\n        random.seed(42)\n        random.shuffle(instances)\n    before_filter = len(instances)\n    instances = [instance for instance in instances if re.match(filter_spec, instance[\"instance_id\"])]\n    if (after_filter := len(instances)) != before_filter:\n        print(f\"Instance filter: {before_filter} -&gt; {after_filter} instances\")\n    if slice_spec:\n        values = [int(x) if x else None for x in slice_spec.split(\":\")]\n        instances = instances[slice(*values)]\n        if (after_slice := len(instances)) != before_filter:\n            print(f\"Instance slice: {before_filter} -&gt; {after_slice} instances\")\n    return instances\n</code></pre>"},{"location":"reference/run/swebench/#minisweagent.run.extra.swebench.main","title":"main","text":"<pre><code>main(\n    subset: str = Option(\n        \"lite\",\n        \"--subset\",\n        help=\"SWEBench subset to use or path to a dataset\",\n    ),\n    split: str = Option(\n        \"dev\", \"--split\", help=\"Dataset split\"\n    ),\n    slice_spec: str = Option(\n        \"\",\n        \"--slice\",\n        help=\"Slice specification (e.g., '0:5' for first 5 instances)\",\n    ),\n    filter_spec: str = Option(\n        \"\", \"--filter\", help=\"Filter instance IDs by regex\"\n    ),\n    shuffle: bool = Option(\n        False, \"--shuffle\", help=\"Shuffle instances\"\n    ),\n    output: str = Option(\n        \"\", \"-o\", \"--output\", help=\"Output directory\"\n    ),\n    workers: int = Option(\n        1,\n        \"-w\",\n        \"--workers\",\n        help=\"Number of worker threads for parallel processing\",\n    ),\n    model: str | None = Option(\n        None, \"-m\", \"--model\", help=\"Model to use\"\n    ),\n    redo_existing: bool = Option(\n        False,\n        \"--redo-existing\",\n        help=\"Redo existing instances\",\n    ),\n    config: Path = Option(\n        builtin_config_dir / \"extra\" / \"swebench.yaml\",\n        \"-c\",\n        \"--config\",\n        help=\"Path to a config file\",\n    ),\n) -&gt; None\n</code></pre> Source code in <code>src/minisweagent/run/extra/swebench.py</code> <pre><code>@app.command(help=_HELP_TEXT)\ndef main(\n    subset: str = typer.Option(\"lite\", \"--subset\", help=\"SWEBench subset to use or path to a dataset\"),\n    split: str = typer.Option(\"dev\", \"--split\", help=\"Dataset split\"),\n    slice_spec: str = typer.Option(\"\", \"--slice\", help=\"Slice specification (e.g., '0:5' for first 5 instances)\"),\n    filter_spec: str = typer.Option(\"\", \"--filter\", help=\"Filter instance IDs by regex\"),\n    shuffle: bool = typer.Option(False, \"--shuffle\", help=\"Shuffle instances\"),\n    output: str = typer.Option(\"\", \"-o\", \"--output\", help=\"Output directory\"),\n    workers: int = typer.Option(1, \"-w\", \"--workers\", help=\"Number of worker threads for parallel processing\"),\n    model: str | None = typer.Option(None, \"-m\", \"--model\", help=\"Model to use\"),\n    redo_existing: bool = typer.Option(False, \"--redo-existing\", help=\"Redo existing instances\"),\n    config: Path = typer.Option(\n        builtin_config_dir / \"extra\" / \"swebench.yaml\", \"-c\", \"--config\", help=\"Path to a config file\"\n    ),\n) -&gt; None:\n    dataset_path = DATASET_MAPPING.get(subset, subset)\n    print(f\"Loading dataset {dataset_path}, split {split}...\")\n    instances = list(load_dataset(dataset_path, split=split))\n\n    instances = filter_instances(instances, filter_spec=filter_spec, slice_spec=slice_spec, shuffle=shuffle)\n    output_path = Path(output)\n    if not redo_existing and (output_path / \"preds.json\").exists():\n        existing_instances = list(json.loads((output_path / \"preds.json\").read_text()).keys())\n        print(f\"Skipping {len(existing_instances)} existing instances\")\n        instances = [instance for instance in instances if instance[\"instance_id\"] not in existing_instances]\n\n    output_path.mkdir(parents=True, exist_ok=True)\n    print(f\"Running on {len(instances)} instances...\")\n    print(f\"Results will be saved to {output_path}\")\n\n    progress_manager = RunBatchProgressManager(len(instances), output_path / f\"exit_statuses_{time.time()}.yaml\")\n\n    def process_futures(futures: dict[concurrent.futures.Future, str]):\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                future.result()\n            except concurrent.futures.CancelledError:\n                pass\n            except Exception as e:\n                instance_id = futures[future]\n                print(f\"Error in future for instance {instance_id}: {e}\")\n                traceback.print_exc()\n                progress_manager.on_uncaught_exception(instance_id, e)\n\n    with Live(progress_manager.render_group, refresh_per_second=4):\n        with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as executor:\n            futures = {\n                executor.submit(process_instance, instance, output_path, model, config, progress_manager): instance[\n                    \"instance_id\"\n                ]\n                for instance in instances\n            }\n            try:\n                process_futures(futures)\n            except KeyboardInterrupt:\n                print(\"Cancelling all pending jobs. Press ^C again to exit immediately.\")\n                for future in futures:\n                    if not future.running() and not future.done():\n                        future.cancel()\n                process_futures(futures)\n</code></pre>"},{"location":"reference/run/swebench_single/","title":"SWE-bench Single","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/run/swebench_single/#minisweagent.run.extra.swebench_single","title":"minisweagent.run.extra.swebench_single","text":"<p>Run on a single SWE-Bench instance.</p>"},{"location":"reference/run/swebench_single/#minisweagent.run.extra.swebench_single.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(add_completion=False)\n</code></pre>"},{"location":"reference/run/swebench_single/#minisweagent.run.extra.swebench_single.main","title":"main","text":"<pre><code>main(\n    subset: str = Option(\n        \"lite\",\n        \"--subset\",\n        help=\"SWEBench subset to use or path to a dataset\",\n    ),\n    split: str = Option(\n        \"dev\", \"--split\", help=\"Dataset split\"\n    ),\n    instance_spec: str = Option(\n        None,\n        \"-i\",\n        \"--instance\",\n        help=\"SWE-Bench instance ID\",\n    ),\n    model_name: str | None = Option(\n        None, \"-m\", \"--model\", help=\"Model to use\"\n    ),\n    config_path: Path = Option(\n        builtin_config_dir / \"extra\" / \"swebench.yaml\",\n        \"-c\",\n        \"--config\",\n        help=\"Path to a config file\",\n    ),\n) -&gt; None\n</code></pre> <p>Run on a single SWE-Bench instance.</p> Source code in <code>src/minisweagent/run/extra/swebench_single.py</code> <pre><code>@app.command()\ndef main(\n    subset: str = typer.Option(\"lite\", \"--subset\", help=\"SWEBench subset to use or path to a dataset\"),\n    split: str = typer.Option(\"dev\", \"--split\", help=\"Dataset split\"),\n    instance_spec: str = typer.Option(None, \"-i\", \"--instance\", help=\"SWE-Bench instance ID\"),\n    model_name: str | None = typer.Option(None, \"-m\", \"--model\", help=\"Model to use\"),\n    config_path: Path = typer.Option(\n        builtin_config_dir / \"extra\" / \"swebench.yaml\", \"-c\", \"--config\", help=\"Path to a config file\"\n    ),\n) -&gt; None:\n    \"\"\"Run on a single SWE-Bench instance.\"\"\"\n    try:\n        dataset_path = DATASET_MAPPING[subset]\n    except KeyError:\n        dataset_path = subset\n    print(f\"Loading dataset {dataset_path}, split {split}...\")\n    instances = {\n        inst[\"instance_id\"]: inst  # type: ignore\n        for inst in load_dataset(dataset_path, split=split)\n    }\n    if instance_spec.isnumeric():\n        instance_spec = sorted(instances.keys())[int(instance_spec)]\n    instance: dict = instances[instance_spec]  # type: ignore\n\n    _config = yaml.safe_load(get_config_path(config_path).read_text())\n    env = DockerEnvironment(**(_config.get(\"environment\", {}) | {\"image\": get_swebench_docker_image_name(instance)}))\n    agent = InteractiveAgent(\n        get_model(model_name, _config.get(\"model\", {})),\n        env,\n        **(_config.get(\"agent\", {}) | {\"mode\": \"yolo\"}),\n    )\n    agent.run(instance[\"problem_statement\"])\n</code></pre>"},{"location":"usage/inspector/","title":"Inspector: Browse agent trajectories","text":"<p>Overview</p> <ul> <li>The <code>inspector</code> is a tool that allows you to browse <code>.traj.json</code> files that show the history of a mini-SWE-agent run.</li> <li>Quickly start it with <code>mini-e i</code> or <code>mini-extra inspector</code>.</li> </ul>"},{"location":"usage/inspector/#usage","title":"Usage","text":"<pre><code># Find all .traj.json files recursively from current directory\nmini-extra inspector\n# or shorter\nmini-e i\n# Open the inspector for a specific file\nmini-e i &lt;path_to_traj.json&gt;\n# Search for trajectory files in a specific directory\nmini-e i &lt;path_to_directory&gt;\n</code></pre>"},{"location":"usage/inspector/#key-bindings","title":"Key bindings","text":"<ul> <li><code>q</code>: Quit the inspector</li> <li><code>h</code>/<code>LEFT</code>: Previous step</li> <li><code>l</code>/<code>RIGHT</code>: Next step</li> <li><code>j</code>/<code>DOWN</code>: Scroll down</li> <li><code>k</code>/<code>UP</code>: Scroll up</li> <li><code>H</code>: Previous trajectory</li> <li><code>L</code>: Next trajectory</li> </ul>"},{"location":"usage/inspector/#faq","title":"FAQ","text":"<p>How can I select/copy text on the screen?</p> <p>Hold down the <code>Alt</code>/<code>Option</code> key and use the mouse to select the text.</p>"},{"location":"usage/inspector/#implementation","title":"Implementation","text":"<p>The inspector is implemented with textual.</p> Implementation <ul> <li>Read on GitHub</li> </ul> <pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple trajectory inspector for browsing agent conversation trajectories.\n\n[not dim]\nMore information about the usage: [bold green]https://mini-swe-agent.com/latest/usage/inspector/[/bold green]\n[/not dim]\n\"\"\"\n\nimport json\nimport os\nfrom pathlib import Path\n\nimport typer\nfrom rich.text import Text\nfrom textual.app import App, ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Container, Vertical, VerticalScroll\nfrom textual.widgets import Footer, Header, Static\n\nfrom minisweagent.agents.interactive_textual import _messages_to_steps\n\napp = typer.Typer(rich_markup_mode=\"rich\", add_completion=False)\n\n\nclass TrajectoryInspector(App):\n    BINDINGS = [\n        Binding(\"right,l\", \"next_step\", \"Step++\"),\n        Binding(\"left,h\", \"previous_step\", \"Step--\"),\n        Binding(\"0\", \"first_step\", \"Step=0\"),\n        Binding(\"$\", \"last_step\", \"Step=-1\"),\n        Binding(\"j,down\", \"scroll_down\", \"Scroll down\"),\n        Binding(\"k,up\", \"scroll_up\", \"Scroll up\"),\n        Binding(\"L\", \"next_trajectory\", \"Next trajectory\"),\n        Binding(\"H\", \"previous_trajectory\", \"Previous trajectory\"),\n        Binding(\"q\", \"quit\", \"Quit\"),\n    ]\n\n    def __init__(self, trajectory_files: list[Path]):\n        css_path = os.environ.get(\n            \"MSWEA_INSPECTOR_STYLE_PATH\", str(Path(__file__).parent.parent / \"config\" / \"mini.tcss\")\n        )\n        self.__class__.CSS = Path(css_path).read_text()\n\n        super().__init__()\n        self.trajectory_files = trajectory_files\n        self._i_trajectory = 0\n        self._i_step = 0\n        self.messages = []\n        self.steps = []\n\n        if trajectory_files:\n            self._load_current_trajectory()\n\n    # --- Basics ---\n\n    @property\n    def i_step(self) -&gt; int:\n        \"\"\"Current step index.\"\"\"\n        return self._i_step\n\n    @i_step.setter\n    def i_step(self, value: int) -&gt; None:\n        \"\"\"Set current step index, automatically clamping to valid bounds.\"\"\"\n        if value != self._i_step and self.n_steps &gt; 0:\n            self._i_step = max(0, min(value, self.n_steps - 1))\n            self.query_one(VerticalScroll).scroll_to(y=0, animate=False)\n            self.update_content()\n\n    @property\n    def n_steps(self) -&gt; int:\n        \"\"\"Number of steps in current trajectory.\"\"\"\n        return len(self.steps)\n\n    @property\n    def i_trajectory(self) -&gt; int:\n        \"\"\"Current trajectory index.\"\"\"\n        return self._i_trajectory\n\n    @i_trajectory.setter\n    def i_trajectory(self, value: int) -&gt; None:\n        \"\"\"Set current trajectory index, automatically clamping to valid bounds.\"\"\"\n        if value != self._i_trajectory and self.n_trajectories &gt; 0:\n            self._i_trajectory = max(0, min(value, self.n_trajectories - 1))\n            self._load_current_trajectory()\n            self.query_one(VerticalScroll).scroll_to(y=0, animate=False)\n            self.update_content()\n\n    @property\n    def n_trajectories(self) -&gt; int:\n        \"\"\"Number of trajectory files.\"\"\"\n        return len(self.trajectory_files)\n\n    def _load_current_trajectory(self) -&gt; None:\n        \"\"\"Load the currently selected trajectory file.\"\"\"\n        if not self.trajectory_files:\n            self.messages = []\n            self.steps = []\n            return\n\n        trajectory_file = self.trajectory_files[self.i_trajectory]\n        try:\n            data = json.loads(trajectory_file.read_text())\n\n            if isinstance(data, list):\n                self.messages = data\n            elif isinstance(data, dict) and \"messages\" in data:\n                self.messages = data[\"messages\"]\n            else:\n                raise ValueError(\"Unrecognized trajectory format\")\n\n            self.steps = _messages_to_steps(self.messages)\n            self._i_step = 0\n        except (json.JSONDecodeError, FileNotFoundError, ValueError) as e:\n            self.messages = []\n            self.steps = []\n            self.notify(f\"Error loading {trajectory_file.name}: {e}\", severity=\"error\")\n\n    @property\n    def current_trajectory_name(self) -&gt; str:\n        \"\"\"Get the name of the current trajectory file.\"\"\"\n        if not self.trajectory_files:\n            return \"No trajectories\"\n        return self.trajectory_files[self.i_trajectory].name\n\n    def compose(self) -&gt; ComposeResult:\n        yield Header()\n        with Container(id=\"main\"):\n            with VerticalScroll():\n                yield Vertical(id=\"content\")\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n        self.update_content()\n\n    def update_content(self) -&gt; None:\n        \"\"\"Update the displayed content.\"\"\"\n        container = self.query_one(\"#content\", Vertical)\n        container.remove_children()\n\n        if not self.steps:\n            container.mount(Static(\"No trajectory loaded or empty trajectory\"))\n            self.title = \"Trajectory Inspector - No Data\"\n            return\n\n        for message in self.steps[self.i_step]:\n            if isinstance(message[\"content\"], list):\n                content_str = \"\\n\".join([item[\"text\"] for item in message[\"content\"]])\n            else:\n                content_str = str(message[\"content\"])\n            message_container = Vertical(classes=\"message-container\")\n            container.mount(message_container)\n            role = message[\"role\"].replace(\"assistant\", \"mini-swe-agent\")\n            message_container.mount(Static(role.upper(), classes=\"message-header\"))\n            message_container.mount(Static(Text(content_str, no_wrap=False), classes=\"message-content\"))\n\n        self.title = (\n            f\"Trajectory {self.i_trajectory + 1}/{self.n_trajectories} - \"\n            f\"{self.current_trajectory_name} - \"\n            f\"Step {self.i_step + 1}/{self.n_steps}\"\n        )\n\n    # --- Navigation actions ---\n\n    def action_next_step(self) -&gt; None:\n        self.i_step += 1\n\n    def action_previous_step(self) -&gt; None:\n        self.i_step -= 1\n\n    def action_first_step(self) -&gt; None:\n        self.i_step = 0\n\n    def action_last_step(self) -&gt; None:\n        self.i_step = self.n_steps - 1\n\n    def action_next_trajectory(self) -&gt; None:\n        self.i_trajectory += 1\n\n    def action_previous_trajectory(self) -&gt; None:\n        self.i_trajectory -= 1\n\n    def action_scroll_down(self) -&gt; None:\n        vs = self.query_one(VerticalScroll)\n        vs.scroll_to(y=vs.scroll_target_y + 15)\n\n    def action_scroll_up(self) -&gt; None:\n        vs = self.query_one(VerticalScroll)\n        vs.scroll_to(y=vs.scroll_target_y - 15)\n\n\n@app.command(help=__doc__)\ndef main(\n    path: str = typer.Argument(\".\", help=\"Directory to search for trajectory files or specific trajectory file\"),\n) -&gt; None:\n    path_obj = Path(path)\n\n    if path_obj.is_file():\n        trajectory_files = [path_obj]\n    elif path_obj.is_dir():\n        trajectory_files = sorted(path_obj.rglob(\"*.traj.json\"))\n        if not trajectory_files:\n            raise typer.BadParameter(f\"No trajectory files found in '{path}'\")\n    else:\n        raise typer.BadParameter(f\"Error: Path '{path}' does not exist\")\n\n    inspector = TrajectoryInspector(trajectory_files)\n    inspector.run()\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"usage/mini/","title":"<code>mini</code>","text":"<p>Overview</p> <ul> <li><code>mini</code> is a REPL-style interactive command line interface for using mini-SWE-agent in the local requirement (as opposed for workflows that require sandboxing or large scale batch processing).</li> <li>Compared to <code>mini -v</code>, <code>mini</code> is more lightweight and does not require threading.</li> </ul> <p>Feedback wanted!</p> <p>Give feedback on the <code>mini</code> and <code>mini -v</code> interfaces at this github issue or in our Slack channel.</p>"},{"location":"usage/mini/#command-line-options","title":"Command line options","text":"<p>Useful switches:</p> <ul> <li><code>-h</code>/<code>--help</code>: Show help</li> <li><code>-t</code>/<code>--task</code>: Specify a task to run (else you will be prompted)</li> <li><code>-c</code>/<code>--config</code>: Specify a config file to use, else we will use <code>mini.yaml</code> or the config <code>MSWEA_MINI_CONFIG_PATH</code> environment variable (see configuration).   It's enough to specify the name of the config file, e.g., <code>-c mini.yaml</code> (see configuration for how it is resolved).</li> <li><code>-m</code>/<code>--model</code>: Specify a model to use, else we will use the model <code>MSWEA_MODEL_NAME</code> environment variable (see configuration)</li> <li><code>-y</code>/<code>--yolo</code>: Start in <code>yolo</code> mode (see below)</li> </ul>"},{"location":"usage/mini/#modes-of-operation","title":"Modes of operation","text":"<p><code>mini</code> provides three different modes of operation</p> <ul> <li><code>confirm</code> (<code>/c</code>): The LM proposes an action and the user is prompted to confirm (press Enter) or reject (enter a rejection message)</li> <li><code>yolo</code> (<code>/y</code>): The action from the LM is executed immediately without confirmation</li> <li><code>human</code> (<code>/u</code>): The user takes over to type and execute commands</li> </ul> <p>You can switch between the modes with the <code>/c</code>, <code>/y</code>, and <code>/u</code> commands that you can enter any time the agent is waiting for input. You can also press <code>Ctrl+C</code> to interrupt the agent at any time, allowing you to switch between modes.</p> <p><code>mini</code> starts in <code>confirm</code> mode by default. To start in <code>yolo</code> mode, you can add <code>-y</code>/<code>--yolo</code> to the command line.</p>"},{"location":"usage/mini/#miscellaneous-tips","title":"Miscellaneous tips","text":"<ul> <li><code>mini</code> saves the full history of your last run to your global config directory.   The path to the directory is printed when you start <code>mini</code>.</li> </ul>"},{"location":"usage/mini/#implementation","title":"Implementation","text":"Default config <ul> <li>Read on GitHub</li> </ul> <pre><code>agent:\n  system_template: |\n    You are a helpful assistant that can interact with a computer.\n\n    Your response must contain exactly ONE bash code block with ONE command (or commands connected with &amp;&amp; or ||).\n    Include a THOUGHT section before your command where you explain your reasoning process.\n    Format your response as shown in &lt;format_example&gt;.\n\n    &lt;format_example&gt;\n    Your reasoning and analysis here. Explain why you want to perform the action.\n\n    ```bash\n    your_command_here\n    ```\n    &lt;/format_example&gt;\n\n    Failure to follow these rules will cause your response to be rejected.\n  instance_template: |\n    Please solve this issue: {{task}}\n\n    You can execute bash commands and edit files to implement the necessary changes.\n\n    ## Recommended Workflow\n\n    This workflows should be done step-by-step so that you can iterate on your changes and any possible problems.\n\n    1. Analyze the codebase by finding and reading relevant files\n    2. Create a script to reproduce the issue\n    3. Edit the source code to resolve the issue\n    4. Verify your fix works by running your script again\n    5. Test edge cases to ensure your fix is robust\n    6. Submit your changes and finish your work by issuing the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`.\n       Do not combine it with any other command. &lt;important&gt;After this command, you cannot continue working on this task.&lt;/important&gt;\n\n    ## Important Rules\n\n    1. Every response must contain exactly one action\n    2. The action must be enclosed in triple backticks\n    3. Directory or environment variable changes are not persistent. Every action is executed in a new subshell.\n       However, you can prefix any action with `MY_ENV_VAR=MY_VALUE cd /path/to/working/dir &amp;&amp; ...` or write/load environment variables from files\n\n    &lt;system_information&gt;\n    {{system}} {{release}} {{version}} {{machine}} {{processor}}\n    &lt;/system_information&gt;\n\n    ## Formatting your response\n\n    Here is an example of a correct response:\n\n    &lt;example_response&gt;\n    THOUGHT: I need to understand the structure of the repository first. Let me check what files are in the current directory to get a better understanding of the codebase.\n\n    ```bash\n    ls -la\n    ```\n    &lt;/example_response&gt;\n\n    ## Useful command examples\n\n    ### Create a new file:\n\n    ```bash\n    cat &lt;&lt;'EOF' &gt; newfile.py\n    import numpy as np\n    hello = \"world\"\n    print(hello)\n    EOF\n    ```\n\n    ### Edit files with sed:\n\n    {%- if system == \"Darwin\" -%}\n    &lt;important&gt;\n    You are on MacOS. For all the below examples, you need to use `sed -i ''` instead of `sed -i`.\n    &lt;/important&gt;\n    {%- endif -%}\n\n    ```bash\n    # Replace all occurrences\n    sed -i 's/old_string/new_string/g' filename.py\n\n    # Replace only first occurrence\n    sed -i 's/old_string/new_string/' filename.py\n\n    # Replace first occurrence on line 1\n    sed -i '1s/old_string/new_string/' filename.py\n\n    # Replace all occurrences in lines 1-10\n    sed -i '1,10s/old_string/new_string/g' filename.py\n    ```\n\n    ### View file content:\n\n    ```bash\n    # View specific lines with numbers\n    nl -ba filename.py | sed -n '10,20p'\n    ```\n\n    ### Any other command you want to run\n\n    ```bash\n    anything\n    ```\n  action_observation_template: |\n    &lt;returncode&gt;{{output.returncode}}&lt;/returncode&gt;\n    {% if output.output | length &lt; 10000 -%}\n    &lt;output&gt;\n    {{ output.output -}}\n    &lt;/output&gt;\n    {%- else -%}\n    &lt;warning&gt;\n    The output of your last command was too long.\n    Please try a different command that produces less output.\n    If you're looking at a file you can try use head, tail or sed to view a smaller number of lines selectively.\n    If you're using grep or find and it produced too much output, you can use a more selective search pattern.\n    If you really need to see something from the full command's output, you can redirect output to a file and then search in that file.\n    &lt;/warning&gt;\n    {%- set elided_chars = output.output | length - 10000 -%}\n    &lt;output_head&gt;\n    {{ output.output[:5000] }}\n    &lt;/output_head&gt;\n    &lt;elided_chars&gt;\n    {{ elided_chars }} characters elided\n    &lt;/elided_chars&gt;\n    &lt;output_tail&gt;\n    {{ output.output[-5000:] }}\n    &lt;/output_tail&gt;\n    {%- endif -%}\n  format_error_template: |\n    Please always provide EXACTLY ONE action in triple backticks, found {{actions|length}} actions.\n    If you want to end the task, please issue the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`\n    without any other command.\n    Else, please format your response exactly as follows:\n\n    &lt;response_example&gt;\n    Here are some thoughts about why you want to perform the action.\n\n    ```bash\n    &lt;action&gt;\n    ```\n    &lt;/response_example&gt;\n\n    Note: In rare cases, if you need to reference a similar format in your command, you might have\n    to proceed in two steps, first writing TRIPLEBACKTICKSBASH, then replacing them with ```bash.\n  step_limit: 0.\n  cost_limit: 3.\n  mode: confirm\nenvironment:\n  env:\n    PAGER: cat\n    MANPAGER: cat\n    LESS: -R\n    PIP_PROGRESS_BAR: 'off'\n    TQDM_DISABLE: '1'\nmodel:\n  model_kwargs:\n    temperature: 0.0\n    drop_params: true\n</code></pre> Run script <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>#!/usr/bin/env python3\n\n\"\"\"Run mini-SWE-agent in your local environment. This is the default executable `mini`.\"\"\"\n# Read this first: https://mini-swe-agent.com/latest/usage/mini/  (usage)\n\nimport os\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport yaml\nfrom prompt_toolkit.formatted_text import HTML\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.shortcuts import PromptSession\nfrom rich.console import Console\n\nfrom minisweagent import Environment, Model, global_config_dir\nfrom minisweagent.agents.interactive import InteractiveAgent\nfrom minisweagent.agents.interactive_textual import AgentApp\nfrom minisweagent.config import builtin_config_dir, get_config_path\nfrom minisweagent.environments.local import LocalEnvironment\nfrom minisweagent.models import get_model\nfrom minisweagent.run.extra.config import configure_if_first_time\nfrom minisweagent.run.utils.save import save_traj\n\nDEFAULT_CONFIG = Path(os.getenv(\"MSWEA_MINI_CONFIG_PATH\", builtin_config_dir / \"mini.yaml\"))\nDEFAULT_OUTPUT = global_config_dir / \"last_mini_run.traj.json\"\nconsole = Console(highlight=False)\napp = typer.Typer(rich_markup_mode=\"rich\")\nprompt_session = PromptSession(history=FileHistory(global_config_dir / \"mini_task_history.txt\"))\n_HELP_TEXT = \"\"\"Run mini-SWE-agent in your local environment.\n\n[not dim]\nThere are two different user interfaces:\n\n[bold green]mini[/bold green] Simple REPL-style interface\n[bold green]mini -v[/bold green] Pager-style interface (Textual)\n\nMore information about the usage: [bold green]https://mini-swe-agent.com/latest/usage/mini/[/bold green]\n[/not dim]\n\"\"\"\n\n\ndef run_interactive(model: Model, env: Environment, agent_config: dict, task: str, output: Path | None = None) -&gt; Any:\n    agent = InteractiveAgent(\n        model,\n        env,\n        **agent_config,\n    )\n\n    exit_status, result = None, None\n    try:\n        exit_status, result = agent.run(task)\n    finally:\n        if output:\n            save_traj(agent, output, exit_status=exit_status, result=result)\n    return agent\n\n\ndef run_textual(model: Model, env: Environment, agent_config: dict, task: str, output: Path | None = None) -&gt; Any:\n    agent_app = AgentApp(\n        model,\n        env,\n        task,\n        **agent_config,\n    )\n    try:\n        agent_app.run()\n    finally:\n        if output:\n            save_traj(agent_app.agent, output, exit_status=agent_app.exit_status, result=agent_app.result)\n\n\n@app.command(help=_HELP_TEXT)\ndef main(\n    visual: bool = typer.Option(\n        False,\n        \"-v\",\n        \"--visual\",\n        help=\"Toggle (pager-style) UI (Textual) depending on the MSWEA_VISUAL_MODE_DEFAULT environment setting\",\n    ),\n    model_name: str | None = typer.Option(\n        None,\n        \"-m\",\n        \"--model\",\n        help=\"Model to use\",\n    ),\n    task: str | None = typer.Option(None, \"-t\", \"--task\", help=\"Task/problem statement\", show_default=False),\n    yolo: bool = typer.Option(False, \"-y\", \"--yolo\", help=\"Run without confirmation\"),\n    cost_limit: float | None = typer.Option(None, \"-l\", \"--cost-limit\", help=\"Cost limit. Set to 0 to disable.\"),\n    config_spec: Path = typer.Option(DEFAULT_CONFIG, \"-c\", \"--config\", help=\"Path to config file\"),\n    output: Path | None = typer.Option(DEFAULT_OUTPUT, \"-o\", \"--output\", help=\"Output trajectory file\"),\n    exit_immediately: bool = typer.Option(\n        False, \"--exit-immediately\", help=\"Exit immediately when the agent wants to finish instead of prompting.\"\n    ),\n) -&gt; Any:\n    configure_if_first_time()\n    config = yaml.safe_load(get_config_path(config_spec).read_text())\n\n    if not task:\n        console.print(\"[bold yellow]What do you want to do?\")\n        task = prompt_session.prompt(\n            \"\",\n            multiline=True,\n            bottom_toolbar=HTML(\n                \"Submit task: &lt;b fg='yellow' bg='black'&gt;Esc+Enter&lt;/b&gt; | \"\n                \"Navigate history: &lt;b fg='yellow' bg='black'&gt;Arrow Up/Down&lt;/b&gt; | \"\n                \"Search history: &lt;b fg='yellow' bg='black'&gt;Ctrl+R&lt;/b&gt;\"\n            ),\n        )\n        console.print(\"[bold green]Got that, thanks![/bold green]\")\n\n    config[\"agent\"][\"mode\"] = \"confirm\" if not yolo else \"yolo\"\n    if cost_limit:\n        config[\"agent\"][\"cost_limit\"] = cost_limit\n    if exit_immediately:\n        config[\"agent\"][\"confirm_exit\"] = False\n    model = get_model(model_name, config.get(\"model\", {}))\n    env = LocalEnvironment(**config.get(\"env\", {}))\n\n    # Both visual flag and the MSWEA_VISUAL_MODE_DEFAULT flip the mode, so it's essentially a XOR\n    if visual == (os.getenv(\"MSWEA_VISUAL_MODE_DEFAULT\", \"false\") == \"false\"):\n        return run_textual(model, env, config[\"agent\"], task, output)  # type: ignore[arg-type]\n    else:\n        return run_interactive(model, env, config[\"agent\"], task, output)  # type: ignore[arg-type]\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> Agent class <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>\"\"\"A small generalization of the default agent that puts the user in the loop.\n\nThere are three modes:\n- human: commands issued by the user are executed immediately\n- confirm: commands issued by the LM but not whitelisted are confirmed by the user\n- yolo: commands issued by the LM are executed immediately without confirmation\n\"\"\"\n\nimport re\nfrom dataclasses import dataclass, field\nfrom typing import Literal\n\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.shortcuts import PromptSession\nfrom rich.console import Console\nfrom rich.rule import Rule\n\nfrom minisweagent import global_config_dir\nfrom minisweagent.agents.default import AgentConfig, DefaultAgent, LimitsExceeded, NonTerminatingException, Submitted\n\nconsole = Console(highlight=False)\nprompt_session = PromptSession(history=FileHistory(global_config_dir / \"interactive_history.txt\"))\n\n\n@dataclass\nclass InteractiveAgentConfig(AgentConfig):\n    mode: Literal[\"human\", \"confirm\", \"yolo\"] = \"confirm\"\n    \"\"\"Whether to confirm actions.\"\"\"\n    whitelist_actions: list[str] = field(default_factory=list)\n    \"\"\"Never confirm actions that match these regular expressions.\"\"\"\n    confirm_exit: bool = True\n    \"\"\"If the agent wants to finish, do we ask for confirmation from user?\"\"\"\n\n\nclass InteractiveAgent(DefaultAgent):\n    _MODE_COMMANDS_MAPPING = {\"/u\": \"human\", \"/c\": \"confirm\", \"/y\": \"yolo\"}\n\n    def __init__(self, *args, config_class=InteractiveAgentConfig, **kwargs):\n        super().__init__(*args, config_class=config_class, **kwargs)\n        self.cost_last_confirmed = 0.0\n\n    def add_message(self, role: str, content: str):\n        # Extend supermethod to print messages\n        super().add_message(role, content)\n        if role == \"assistant\":\n            console.print(\n                f\"\\n[red][bold]mini-swe-agent[/bold] (step [bold]{self.model.n_calls}[/bold], [bold]${self.model.cost:.2f}[/bold]):[/red]\\n\",\n                end=\"\",\n                highlight=False,\n            )\n        else:\n            console.print(f\"\\n[bold green]{role.capitalize()}[/bold green]:\\n\", end=\"\", highlight=False)\n        console.print(content, highlight=False, markup=False)\n\n    def query(self) -&gt; dict:\n        # Extend supermethod to handle human mode\n        if self.config.mode == \"human\":\n            match command := self._prompt_and_handle_special(\"[bold yellow]&gt;[/bold yellow] \"):\n                case \"/y\" | \"/c\":  # Just go to the super query, which queries the LM for the next action\n                    pass\n                case _:\n                    msg = {\"content\": f\"\\n```bash\\n{command}\\n```\"}\n                    self.add_message(\"assistant\", msg[\"content\"])\n                    return msg\n        try:\n            with console.status(\"Waiting for the LM to respond...\"):\n                return super().query()\n        except LimitsExceeded:\n            console.print(\n                f\"Limits exceeded. Limits: {self.config.step_limit} steps, ${self.config.cost_limit}.\\n\"\n                f\"Current spend: {self.model.n_calls} steps, ${self.model.cost:.2f}.\"\n            )\n            self.config.step_limit = int(input(\"New step limit: \"))\n            self.config.cost_limit = float(input(\"New cost limit: \"))\n            return super().query()\n\n    def step(self) -&gt; dict:\n        # Override the step method to handle user interruption\n        try:\n            console.print(Rule())\n            return super().step()\n        except KeyboardInterrupt:\n            # We always add a message about the interrupt and then just proceed to the next step\n            interruption_message = self._prompt_and_handle_special(\n                \"\\n\\n[bold yellow]Interrupted.[/bold yellow] \"\n                \"[green]Type a comment/command[/green] (/h for available commands)\"\n                \"\\n[bold yellow]&gt;[/bold yellow] \"\n            ).strip()\n            if not interruption_message or interruption_message in self._MODE_COMMANDS_MAPPING:\n                interruption_message = \"Temporary interruption caught.\"\n            raise NonTerminatingException(f\"Interrupted by user: {interruption_message}\")\n\n    def execute_action(self, action: dict) -&gt; dict:\n        # Override the execute_action method to handle user confirmation\n        if self.should_ask_confirmation(action[\"action\"]):\n            self.ask_confirmation()\n        return super().execute_action(action)\n\n    def should_ask_confirmation(self, action: str) -&gt; bool:\n        return self.config.mode == \"confirm\" and not any(re.match(r, action) for r in self.config.whitelist_actions)\n\n    def ask_confirmation(self) -&gt; None:\n        prompt = (\n            \"[bold yellow]Execute?[/bold yellow] [green][bold]Enter[/bold] to confirm[/green], \"\n            \"or [green]Type a comment/command[/green] (/h for available commands)\\n\"\n            \"[bold yellow]&gt;[/bold yellow] \"\n        )\n        match user_input := self._prompt_and_handle_special(prompt).strip():\n            case \"\" | \"/y\":\n                pass  # confirmed, do nothing\n            case \"/u\":  # Skip execution action and get back to query\n                raise NonTerminatingException(\"Command not executed. Switching to human mode\")\n            case _:\n                raise NonTerminatingException(\n                    f\"Command not executed. The user rejected your command with the following message: {user_input}\"\n                )\n\n    def _prompt_and_handle_special(self, prompt: str) -&gt; str:\n        \"\"\"Prompts the user, takes care of /h (followed by requery) and sets the mode. Returns the user input.\"\"\"\n        console.print(prompt, end=\"\")\n        user_input = prompt_session.prompt(\"\")\n        if user_input == \"/h\":\n            console.print(\n                f\"Current mode: [bold green]{self.config.mode}[/bold green]\\n\"\n                f\"[bold green]/y[/bold green] to switch to [bold yellow]yolo[/bold yellow] mode (execute LM commands without confirmation)\\n\"\n                f\"[bold green]/c[/bold green] to switch to [bold yellow]confirmation[/bold yellow] mode (ask for confirmation before executing LM commands)\\n\"\n                f\"[bold green]/u[/bold green] to switch to [bold yellow]human[/bold yellow] mode (execute commands issued by the user)\\n\"\n            )\n            return self._prompt_and_handle_special(prompt)\n        if user_input in self._MODE_COMMANDS_MAPPING:\n            if self.config.mode == self._MODE_COMMANDS_MAPPING[user_input]:\n                return self._prompt_and_handle_special(\n                    f\"[bold red]Already in {self.config.mode} mode.[/bold red]\\n{prompt}\"\n                )\n            self.config.mode = self._MODE_COMMANDS_MAPPING[user_input]\n            console.print(f\"Switched to [bold green]{self.config.mode}[/bold green] mode.\")\n            return user_input\n        return user_input\n\n    def has_finished(self, output: dict[str, str]):\n        try:\n            return super().has_finished(output)\n        except Submitted as e:\n            if self.config.confirm_exit:\n                console.print(\n                    \"[bold green]Agent wants to finish.[/bold green] \"\n                    \"[green]Type a comment to give it a new task or press enter to quit.\\n\"\n                    \"[bold yellow]&gt;[/bold yellow] \",\n                    end=\"\",\n                )\n                if new_task := self._prompt_and_handle_special(\"\").strip():\n                    raise NonTerminatingException(f\"The user added a new task: {new_task}\")\n            raise e\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"usage/mini_v/","title":"<code>mini -v</code>","text":"<p>Overview</p> <ul> <li><code>mini -v</code> is a pager-style interactive command line interface for using mini-SWE-agent in the local requirement (as opposed for workflows that require sandboxing or large scale batch processing).</li> <li>Compared to <code>mini</code>, <code>mini -v</code> offers a more advanced UI based on Textual.</li> </ul> <p>Feedback wanted!</p> <p>Give feedback on the <code>mini</code> and <code>mini -v</code> interfaces at this github issue or in our Slack channel.</p>"},{"location":"usage/mini_v/#command-line-options","title":"Command line options","text":"<p>Invocation</p> <pre><code>mini -v [other options]\n</code></pre> <p>Default visual mode</p> <p>If you want to use the visual mode by default, you can set the <code>MSWEA_VISUAL_MODE_DEFAULT</code> environment variable to <code>true</code> (<code>mini-extra config set MSWEA_VISUAL_MODE_DEFAULT true</code>).</p> <p>Useful switches:</p> <ul> <li><code>-h</code>/<code>--help</code>: Show help</li> <li><code>-t</code>/<code>--task</code>: Specify a task to run (else you will be prompted)</li> <li><code>-c</code>/<code>--config</code>: Specify a config file to use, else we will use <code>mini.yaml</code> or the config <code>MSWEA_MINI_CONFIG_PATH</code> environment variable (see configuration)   It's enough to specify the name of the config file, e.g., <code>-c mini.yaml</code> (see configuration for how it is resolved).</li> <li><code>-m</code>/<code>--model</code>: Specify a model to use, else we will use the model <code>MSWEA_MODEL_NAME</code> environment variable (see configuration)</li> <li><code>-y</code>/<code>--yolo</code>: Start in <code>yolo</code> mode (see below)</li> </ul>"},{"location":"usage/mini_v/#key-bindings","title":"Key bindings","text":"<p>Focused input fields</p> <p>Whenever you are prompted to enter text, the input field will be focused. You can use <code>Tab</code> or <code>Esc</code> to switch between the input field controls and the general controls below.</p> <ul> <li><code>f1</code> or <code>?</code>: Show keybinding help</li> <li><code>q</code> (or <code>ctrl+q</code>): Quit the agent</li> <li><code>c</code>: Switch to <code>confirm</code> mode</li> <li><code>y</code> (or <code>ctrl+y</code>): Switch to <code>yolo</code> mode</li> <li><code>h</code> or <code>LEFT</code>: Go to previous step of the agent</li> <li><code>l</code> or <code>RIGHT</code>: Go to next step of the agent</li> <li><code>0</code>: Go to first step of the agent</li> <li><code>$</code>: Go to last step of the agent</li> <li><code>j</code> or <code>DOWN</code>: Scroll down</li> <li><code>k</code> or <code>UP</code>: Scroll up</li> </ul>"},{"location":"usage/mini_v/#modes-of-operation","title":"Modes of operation","text":"<p><code>mini -v</code> provides two different modes of operation</p> <ul> <li><code>confirm</code> (<code>c</code>): The LM proposes an action and the user is prompted to confirm (press Enter)) or reject (enter a rejection message))</li> <li><code>yolo</code> (<code>y</code>): The action from the LM is executed immediately without confirmation</li> <li><code>human</code> (<code>u</code>): The user is prompted to enter a command directly</li> </ul> <p>You can switch between the modes at any time by pressing the <code>c</code>, <code>y</code>, or <code>u</code> keys.</p> <p><code>mini -v</code> starts in <code>confirm</code> mode by default. To start in <code>yolo</code> mode, you can add <code>-y</code>/<code>--yolo</code> to the command line.</p>"},{"location":"usage/mini_v/#faq","title":"FAQ","text":"<p>How can I select/copy text on the screen?</p> <p>Hold down the <code>Alt</code>/<code>Option</code> key and use the mouse to select the text.</p>"},{"location":"usage/mini_v/#miscellaneous-tips","title":"Miscellaneous tips","text":"<ul> <li><code>mini</code> saves the full history of your last run to your global config directory.   The path to the directory is printed when you start <code>mini</code>.</li> </ul>"},{"location":"usage/mini_v/#implementation","title":"Implementation","text":"Default config <ul> <li>Read on GitHub</li> </ul> <pre><code>agent:\n  system_template: |\n    You are a helpful assistant that can interact with a computer.\n\n    Your response must contain exactly ONE bash code block with ONE command (or commands connected with &amp;&amp; or ||).\n    Include a THOUGHT section before your command where you explain your reasoning process.\n    Format your response as shown in &lt;format_example&gt;.\n\n    &lt;format_example&gt;\n    Your reasoning and analysis here. Explain why you want to perform the action.\n\n    ```bash\n    your_command_here\n    ```\n    &lt;/format_example&gt;\n\n    Failure to follow these rules will cause your response to be rejected.\n  instance_template: |\n    Please solve this issue: {{task}}\n\n    You can execute bash commands and edit files to implement the necessary changes.\n\n    ## Recommended Workflow\n\n    This workflows should be done step-by-step so that you can iterate on your changes and any possible problems.\n\n    1. Analyze the codebase by finding and reading relevant files\n    2. Create a script to reproduce the issue\n    3. Edit the source code to resolve the issue\n    4. Verify your fix works by running your script again\n    5. Test edge cases to ensure your fix is robust\n    6. Submit your changes and finish your work by issuing the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`.\n       Do not combine it with any other command. &lt;important&gt;After this command, you cannot continue working on this task.&lt;/important&gt;\n\n    ## Important Rules\n\n    1. Every response must contain exactly one action\n    2. The action must be enclosed in triple backticks\n    3. Directory or environment variable changes are not persistent. Every action is executed in a new subshell.\n       However, you can prefix any action with `MY_ENV_VAR=MY_VALUE cd /path/to/working/dir &amp;&amp; ...` or write/load environment variables from files\n\n    &lt;system_information&gt;\n    {{system}} {{release}} {{version}} {{machine}} {{processor}}\n    &lt;/system_information&gt;\n\n    ## Formatting your response\n\n    Here is an example of a correct response:\n\n    &lt;example_response&gt;\n    THOUGHT: I need to understand the structure of the repository first. Let me check what files are in the current directory to get a better understanding of the codebase.\n\n    ```bash\n    ls -la\n    ```\n    &lt;/example_response&gt;\n\n    ## Useful command examples\n\n    ### Create a new file:\n\n    ```bash\n    cat &lt;&lt;'EOF' &gt; newfile.py\n    import numpy as np\n    hello = \"world\"\n    print(hello)\n    EOF\n    ```\n\n    ### Edit files with sed:\n\n    {%- if system == \"Darwin\" -%}\n    &lt;important&gt;\n    You are on MacOS. For all the below examples, you need to use `sed -i ''` instead of `sed -i`.\n    &lt;/important&gt;\n    {%- endif -%}\n\n    ```bash\n    # Replace all occurrences\n    sed -i 's/old_string/new_string/g' filename.py\n\n    # Replace only first occurrence\n    sed -i 's/old_string/new_string/' filename.py\n\n    # Replace first occurrence on line 1\n    sed -i '1s/old_string/new_string/' filename.py\n\n    # Replace all occurrences in lines 1-10\n    sed -i '1,10s/old_string/new_string/g' filename.py\n    ```\n\n    ### View file content:\n\n    ```bash\n    # View specific lines with numbers\n    nl -ba filename.py | sed -n '10,20p'\n    ```\n\n    ### Any other command you want to run\n\n    ```bash\n    anything\n    ```\n  action_observation_template: |\n    &lt;returncode&gt;{{output.returncode}}&lt;/returncode&gt;\n    {% if output.output | length &lt; 10000 -%}\n    &lt;output&gt;\n    {{ output.output -}}\n    &lt;/output&gt;\n    {%- else -%}\n    &lt;warning&gt;\n    The output of your last command was too long.\n    Please try a different command that produces less output.\n    If you're looking at a file you can try use head, tail or sed to view a smaller number of lines selectively.\n    If you're using grep or find and it produced too much output, you can use a more selective search pattern.\n    If you really need to see something from the full command's output, you can redirect output to a file and then search in that file.\n    &lt;/warning&gt;\n    {%- set elided_chars = output.output | length - 10000 -%}\n    &lt;output_head&gt;\n    {{ output.output[:5000] }}\n    &lt;/output_head&gt;\n    &lt;elided_chars&gt;\n    {{ elided_chars }} characters elided\n    &lt;/elided_chars&gt;\n    &lt;output_tail&gt;\n    {{ output.output[-5000:] }}\n    &lt;/output_tail&gt;\n    {%- endif -%}\n  format_error_template: |\n    Please always provide EXACTLY ONE action in triple backticks, found {{actions|length}} actions.\n    If you want to end the task, please issue the following command: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`\n    without any other command.\n    Else, please format your response exactly as follows:\n\n    &lt;response_example&gt;\n    Here are some thoughts about why you want to perform the action.\n\n    ```bash\n    &lt;action&gt;\n    ```\n    &lt;/response_example&gt;\n\n    Note: In rare cases, if you need to reference a similar format in your command, you might have\n    to proceed in two steps, first writing TRIPLEBACKTICKSBASH, then replacing them with ```bash.\n  step_limit: 0.\n  cost_limit: 3.\n  mode: confirm\nenvironment:\n  env:\n    PAGER: cat\n    MANPAGER: cat\n    LESS: -R\n    PIP_PROGRESS_BAR: 'off'\n    TQDM_DISABLE: '1'\nmodel:\n  model_kwargs:\n    temperature: 0.0\n    drop_params: true\n</code></pre> Run script <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>#!/usr/bin/env python3\n\n\"\"\"Run mini-SWE-agent in your local environment. This is the default executable `mini`.\"\"\"\n# Read this first: https://mini-swe-agent.com/latest/usage/mini/  (usage)\n\nimport os\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport yaml\nfrom prompt_toolkit.formatted_text import HTML\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.shortcuts import PromptSession\nfrom rich.console import Console\n\nfrom minisweagent import Environment, Model, global_config_dir\nfrom minisweagent.agents.interactive import InteractiveAgent\nfrom minisweagent.agents.interactive_textual import AgentApp\nfrom minisweagent.config import builtin_config_dir, get_config_path\nfrom minisweagent.environments.local import LocalEnvironment\nfrom minisweagent.models import get_model\nfrom minisweagent.run.extra.config import configure_if_first_time\nfrom minisweagent.run.utils.save import save_traj\n\nDEFAULT_CONFIG = Path(os.getenv(\"MSWEA_MINI_CONFIG_PATH\", builtin_config_dir / \"mini.yaml\"))\nDEFAULT_OUTPUT = global_config_dir / \"last_mini_run.traj.json\"\nconsole = Console(highlight=False)\napp = typer.Typer(rich_markup_mode=\"rich\")\nprompt_session = PromptSession(history=FileHistory(global_config_dir / \"mini_task_history.txt\"))\n_HELP_TEXT = \"\"\"Run mini-SWE-agent in your local environment.\n\n[not dim]\nThere are two different user interfaces:\n\n[bold green]mini[/bold green] Simple REPL-style interface\n[bold green]mini -v[/bold green] Pager-style interface (Textual)\n\nMore information about the usage: [bold green]https://mini-swe-agent.com/latest/usage/mini/[/bold green]\n[/not dim]\n\"\"\"\n\n\ndef run_interactive(model: Model, env: Environment, agent_config: dict, task: str, output: Path | None = None) -&gt; Any:\n    agent = InteractiveAgent(\n        model,\n        env,\n        **agent_config,\n    )\n\n    exit_status, result = None, None\n    try:\n        exit_status, result = agent.run(task)\n    finally:\n        if output:\n            save_traj(agent, output, exit_status=exit_status, result=result)\n    return agent\n\n\ndef run_textual(model: Model, env: Environment, agent_config: dict, task: str, output: Path | None = None) -&gt; Any:\n    agent_app = AgentApp(\n        model,\n        env,\n        task,\n        **agent_config,\n    )\n    try:\n        agent_app.run()\n    finally:\n        if output:\n            save_traj(agent_app.agent, output, exit_status=agent_app.exit_status, result=agent_app.result)\n\n\n@app.command(help=_HELP_TEXT)\ndef main(\n    visual: bool = typer.Option(\n        False,\n        \"-v\",\n        \"--visual\",\n        help=\"Toggle (pager-style) UI (Textual) depending on the MSWEA_VISUAL_MODE_DEFAULT environment setting\",\n    ),\n    model_name: str | None = typer.Option(\n        None,\n        \"-m\",\n        \"--model\",\n        help=\"Model to use\",\n    ),\n    task: str | None = typer.Option(None, \"-t\", \"--task\", help=\"Task/problem statement\", show_default=False),\n    yolo: bool = typer.Option(False, \"-y\", \"--yolo\", help=\"Run without confirmation\"),\n    cost_limit: float | None = typer.Option(None, \"-l\", \"--cost-limit\", help=\"Cost limit. Set to 0 to disable.\"),\n    config_spec: Path = typer.Option(DEFAULT_CONFIG, \"-c\", \"--config\", help=\"Path to config file\"),\n    output: Path | None = typer.Option(DEFAULT_OUTPUT, \"-o\", \"--output\", help=\"Output trajectory file\"),\n    exit_immediately: bool = typer.Option(\n        False, \"--exit-immediately\", help=\"Exit immediately when the agent wants to finish instead of prompting.\"\n    ),\n) -&gt; Any:\n    configure_if_first_time()\n    config = yaml.safe_load(get_config_path(config_spec).read_text())\n\n    if not task:\n        console.print(\"[bold yellow]What do you want to do?\")\n        task = prompt_session.prompt(\n            \"\",\n            multiline=True,\n            bottom_toolbar=HTML(\n                \"Submit task: &lt;b fg='yellow' bg='black'&gt;Esc+Enter&lt;/b&gt; | \"\n                \"Navigate history: &lt;b fg='yellow' bg='black'&gt;Arrow Up/Down&lt;/b&gt; | \"\n                \"Search history: &lt;b fg='yellow' bg='black'&gt;Ctrl+R&lt;/b&gt;\"\n            ),\n        )\n        console.print(\"[bold green]Got that, thanks![/bold green]\")\n\n    config[\"agent\"][\"mode\"] = \"confirm\" if not yolo else \"yolo\"\n    if cost_limit:\n        config[\"agent\"][\"cost_limit\"] = cost_limit\n    if exit_immediately:\n        config[\"agent\"][\"confirm_exit\"] = False\n    model = get_model(model_name, config.get(\"model\", {}))\n    env = LocalEnvironment(**config.get(\"env\", {}))\n\n    # Both visual flag and the MSWEA_VISUAL_MODE_DEFAULT flip the mode, so it's essentially a XOR\n    if visual == (os.getenv(\"MSWEA_VISUAL_MODE_DEFAULT\", \"false\") == \"false\"):\n        return run_textual(model, env, config[\"agent\"], task, output)  # type: ignore[arg-type]\n    else:\n        return run_interactive(model, env, config[\"agent\"], task, output)  # type: ignore[arg-type]\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> Agent class <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>\"\"\"A small generalization of the default agent that puts the user in the loop.\n\nThere are three modes:\n- human: commands issued by the user are executed immediately\n- confirm: commands issued by the LM but not whitelisted are confirmed by the user\n- yolo: commands issued by the LM are executed immediately without confirmation\n\"\"\"\n\nimport re\nfrom dataclasses import dataclass, field\nfrom typing import Literal\n\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.shortcuts import PromptSession\nfrom rich.console import Console\nfrom rich.rule import Rule\n\nfrom minisweagent import global_config_dir\nfrom minisweagent.agents.default import AgentConfig, DefaultAgent, LimitsExceeded, NonTerminatingException, Submitted\n\nconsole = Console(highlight=False)\nprompt_session = PromptSession(history=FileHistory(global_config_dir / \"interactive_history.txt\"))\n\n\n@dataclass\nclass InteractiveAgentConfig(AgentConfig):\n    mode: Literal[\"human\", \"confirm\", \"yolo\"] = \"confirm\"\n    \"\"\"Whether to confirm actions.\"\"\"\n    whitelist_actions: list[str] = field(default_factory=list)\n    \"\"\"Never confirm actions that match these regular expressions.\"\"\"\n    confirm_exit: bool = True\n    \"\"\"If the agent wants to finish, do we ask for confirmation from user?\"\"\"\n\n\nclass InteractiveAgent(DefaultAgent):\n    _MODE_COMMANDS_MAPPING = {\"/u\": \"human\", \"/c\": \"confirm\", \"/y\": \"yolo\"}\n\n    def __init__(self, *args, config_class=InteractiveAgentConfig, **kwargs):\n        super().__init__(*args, config_class=config_class, **kwargs)\n        self.cost_last_confirmed = 0.0\n\n    def add_message(self, role: str, content: str):\n        # Extend supermethod to print messages\n        super().add_message(role, content)\n        if role == \"assistant\":\n            console.print(\n                f\"\\n[red][bold]mini-swe-agent[/bold] (step [bold]{self.model.n_calls}[/bold], [bold]${self.model.cost:.2f}[/bold]):[/red]\\n\",\n                end=\"\",\n                highlight=False,\n            )\n        else:\n            console.print(f\"\\n[bold green]{role.capitalize()}[/bold green]:\\n\", end=\"\", highlight=False)\n        console.print(content, highlight=False, markup=False)\n\n    def query(self) -&gt; dict:\n        # Extend supermethod to handle human mode\n        if self.config.mode == \"human\":\n            match command := self._prompt_and_handle_special(\"[bold yellow]&gt;[/bold yellow] \"):\n                case \"/y\" | \"/c\":  # Just go to the super query, which queries the LM for the next action\n                    pass\n                case _:\n                    msg = {\"content\": f\"\\n```bash\\n{command}\\n```\"}\n                    self.add_message(\"assistant\", msg[\"content\"])\n                    return msg\n        try:\n            with console.status(\"Waiting for the LM to respond...\"):\n                return super().query()\n        except LimitsExceeded:\n            console.print(\n                f\"Limits exceeded. Limits: {self.config.step_limit} steps, ${self.config.cost_limit}.\\n\"\n                f\"Current spend: {self.model.n_calls} steps, ${self.model.cost:.2f}.\"\n            )\n            self.config.step_limit = int(input(\"New step limit: \"))\n            self.config.cost_limit = float(input(\"New cost limit: \"))\n            return super().query()\n\n    def step(self) -&gt; dict:\n        # Override the step method to handle user interruption\n        try:\n            console.print(Rule())\n            return super().step()\n        except KeyboardInterrupt:\n            # We always add a message about the interrupt and then just proceed to the next step\n            interruption_message = self._prompt_and_handle_special(\n                \"\\n\\n[bold yellow]Interrupted.[/bold yellow] \"\n                \"[green]Type a comment/command[/green] (/h for available commands)\"\n                \"\\n[bold yellow]&gt;[/bold yellow] \"\n            ).strip()\n            if not interruption_message or interruption_message in self._MODE_COMMANDS_MAPPING:\n                interruption_message = \"Temporary interruption caught.\"\n            raise NonTerminatingException(f\"Interrupted by user: {interruption_message}\")\n\n    def execute_action(self, action: dict) -&gt; dict:\n        # Override the execute_action method to handle user confirmation\n        if self.should_ask_confirmation(action[\"action\"]):\n            self.ask_confirmation()\n        return super().execute_action(action)\n\n    def should_ask_confirmation(self, action: str) -&gt; bool:\n        return self.config.mode == \"confirm\" and not any(re.match(r, action) for r in self.config.whitelist_actions)\n\n    def ask_confirmation(self) -&gt; None:\n        prompt = (\n            \"[bold yellow]Execute?[/bold yellow] [green][bold]Enter[/bold] to confirm[/green], \"\n            \"or [green]Type a comment/command[/green] (/h for available commands)\\n\"\n            \"[bold yellow]&gt;[/bold yellow] \"\n        )\n        match user_input := self._prompt_and_handle_special(prompt).strip():\n            case \"\" | \"/y\":\n                pass  # confirmed, do nothing\n            case \"/u\":  # Skip execution action and get back to query\n                raise NonTerminatingException(\"Command not executed. Switching to human mode\")\n            case _:\n                raise NonTerminatingException(\n                    f\"Command not executed. The user rejected your command with the following message: {user_input}\"\n                )\n\n    def _prompt_and_handle_special(self, prompt: str) -&gt; str:\n        \"\"\"Prompts the user, takes care of /h (followed by requery) and sets the mode. Returns the user input.\"\"\"\n        console.print(prompt, end=\"\")\n        user_input = prompt_session.prompt(\"\")\n        if user_input == \"/h\":\n            console.print(\n                f\"Current mode: [bold green]{self.config.mode}[/bold green]\\n\"\n                f\"[bold green]/y[/bold green] to switch to [bold yellow]yolo[/bold yellow] mode (execute LM commands without confirmation)\\n\"\n                f\"[bold green]/c[/bold green] to switch to [bold yellow]confirmation[/bold yellow] mode (ask for confirmation before executing LM commands)\\n\"\n                f\"[bold green]/u[/bold green] to switch to [bold yellow]human[/bold yellow] mode (execute commands issued by the user)\\n\"\n            )\n            return self._prompt_and_handle_special(prompt)\n        if user_input in self._MODE_COMMANDS_MAPPING:\n            if self.config.mode == self._MODE_COMMANDS_MAPPING[user_input]:\n                return self._prompt_and_handle_special(\n                    f\"[bold red]Already in {self.config.mode} mode.[/bold red]\\n{prompt}\"\n                )\n            self.config.mode = self._MODE_COMMANDS_MAPPING[user_input]\n            console.print(f\"Switched to [bold green]{self.config.mode}[/bold green] mode.\")\n            return user_input\n        return user_input\n\n    def has_finished(self, output: dict[str, str]):\n        try:\n            return super().has_finished(output)\n        except Submitted as e:\n            if self.config.confirm_exit:\n                console.print(\n                    \"[bold green]Agent wants to finish.[/bold green] \"\n                    \"[green]Type a comment to give it a new task or press enter to quit.\\n\"\n                    \"[bold yellow]&gt;[/bold yellow] \",\n                    end=\"\",\n                )\n                if new_task := self._prompt_and_handle_special(\"\").strip():\n                    raise NonTerminatingException(f\"The user added a new task: {new_task}\")\n            raise e\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"usage/swebench/","title":"SWE-bench","text":"<p>Overview</p> <ul> <li>We provide two scripts to run on the SWE-bench benchmark.</li> <li><code>mini-extra swebench</code> runs on all task instances in batch mode.</li> <li><code>mini-extra swebench-single</code> runs on a single task instance with interactivity (useful for debugging).</li> </ul>"},{"location":"usage/swebench/#usage","title":"Usage","text":"Batch modeSingle instance (for debugging) <pre><code>mini-extra swebench --help\n# or\npython src/minisweagent/run/extra/swebench.py --help\n# Example:\nmini-extra swebench \\\n    --model claude-sonnet-4-20250514 \\\n    --subset verified \\\n    --split test \\\n    --workers 4\n</code></pre> <pre><code>mini-extra swebench-single --help\n# or\npython src/minisweagent/run/extra/swebench_single.py --help\n# Example:\nmini-extra swebench-single \\\n    --subset verified \\\n    --split test \\\n    --model claude-sonnet-4-20250514 \\\n    -i sympy__sympy-15599\n# or\nmini-extra swebench-single \\\n    --subset verified \\\n    --split test \\\n    -m claude-sonnet-4-20250514 \\\n    -i 0  # instance index\n</code></pre> <p>Evaluating on SWE-bench</p> <p>You can use the sb-cli for extremely fast, cloud-based evaluations (and it's free!). After installing it and getting a token, simply run:</p> <pre><code>sb-cli submit swe-bench_verified test --predictions_path preds.json --run_id some-id-for-your-run\n</code></pre> <p>Typically you will have results within 20 minutes (this is not limited by how many instances you run, but by the slowest-to-evaluate instance in SWE-bench).</p>"},{"location":"usage/swebench/#faq","title":"FAQ","text":"<p>Can I set global cost limits?</p> <p>Yes, you can set global cost limits with the <code>MSWEA_GLOBAL_CALL_LIMIT</code> and <code>MSWEA_GLOBAL_COST_LIMIT</code> environment variables/global config. See configuration for more details.</p> <p>What happens to uncompleted tasks when I abort with KeyboardInterrupt?</p> <p>Trajectories are only saved upon completion, so most likely, you can just rerun the script to complete the tasks next time. However, you should still check for <code>KeyboardInterrupt</code> in <code>preds.json</code> in case some tasks were aborted but saved.</p> <p>Certain tasks are being stuck even though I deleted the trajectories.</p> <p>The completed instances are inferred from <code>preds.json</code>. Remove the corresponding items from the file.</p> <p>How can I run on a different dataset?</p> <p>As long as it follows the SWE-bench format, you can use <code>--subset /path/to/your/dataset</code> to run on a custom dataset. The dataset needs to be loadable as <code>datasets.load_dataset(path, split=split)</code>.</p> <p>Some progress runners are stuck at 'initializing task' for a very long time</p> <p>They might be pulling docker containers -- the run sshould start immediately the next time.</p>"},{"location":"usage/swebench/#implementation","title":"Implementation","text":"Default config <ul> <li>Read on GitHub</li> </ul> <pre><code>agent:\n  system_template: |\n    You are a helpful assistant that can interact multiple times with a computer shell to solve programming tasks.\n    Your response must contain exactly ONE bash code block with ONE command (or commands connected with &amp;&amp; or ||).\n\n    Include a THOUGHT section before your command where you explain your reasoning process.\n    Format your response as shown in &lt;format_example&gt;.\n\n    &lt;format_example&gt;\n    THOUGHT: Your reasoning and analysis here\n\n    ```bash\n    your_command_here\n    ```\n    &lt;/format_example&gt;\n\n    Failure to follow these rules will cause your response to be rejected.\n  instance_template: |\n    &lt;pr_description&gt;\n    Consider the following PR description:\n    {{task}}\n    &lt;/pr_description&gt;\n\n    &lt;instructions&gt;\n    # Task Instructions\n\n    ## Overview\n    You're a software engineer interacting continuously with a computer by submitting commands.\n    You'll be helping implement necessary changes to meet requirements in the PR description.\n    Your task is specifically to make changes to non-test files in the current directory in order to fix the issue described in the PR description in a way that is general and consistent with the codebase.\n\n    IMPORTANT: This is an interactive process where you will think and issue ONE command, see its result, then think and issue your next command.\n\n    For each response:\n    1. Include a THOUGHT section explaining your reasoning and what you're trying to accomplish\n    2. Provide exactly ONE bash command to execute\n\n    ## Important Boundaries\n    - MODIFY: Regular source code files in {{working_dir}}\n    - DO NOT MODIFY: Tests, configuration files (pyproject.toml, setup.cfg, etc.)\n\n    ## Recommended Workflow\n    1. Analyze the codebase by finding and reading relevant files\n    2. Create a script to reproduce the issue\n    3. Edit the source code to resolve the issue\n    4. Verify your fix works by running your script again\n    5. Test edge cases to ensure your fix is robust\n\n    ## Command Execution Rules\n    You are operating in an environment where\n    1. You write a single command\n    2. The system executes that command in a subshell\n    3. You see the result\n    4. You write your next command\n\n    Each response should include:\n    1. A **THOUGHT** section where you explain your reasoning and plan\n    2. A single bash code block with your command\n\n    Format your responses like this:\n\n    &lt;format_example&gt;\n    THOUGHT: Here I explain my reasoning process, analysis of the current situation,\n    and what I'm trying to accomplish with the command below.\n\n    ```bash\n    your_command_here\n    ```\n    &lt;/format_example&gt;\n\n    Commands must be specified in a single bash code block:\n\n    ```bash\n    your_command_here\n    ```\n\n    **CRITICAL REQUIREMENTS:**\n    - Your response SHOULD include a THOUGHT section explaining your reasoning\n    - Your response MUST include EXACTLY ONE bash code block\n    - This bash block MUST contain EXACTLY ONE command (or a set of commands connected with &amp;&amp; or ||)\n    - If you include zero or multiple bash blocks, or no command at all, YOUR RESPONSE WILL FAIL\n    - Do NOT try to run multiple independent commands in separate blocks in one response\n    - Directory or environment variable changes are not persistent. Every action is executed in a new subshell.\n    - However, you can prefix any action with `MY_ENV_VAR=MY_VALUE cd /path/to/working/dir &amp;&amp; ...` or write/load environment variables from files\n\n    Example of a CORRECT response:\n    &lt;example_response&gt;\n    THOUGHT: I need to understand the structure of the repository first. Let me check what files are in the current directory to get a better understanding of the codebase.\n\n    ```bash\n    ls -la\n    ```\n    &lt;/example_response&gt;\n\n    Example of an INCORRECT response:\n    &lt;example_response&gt;\n    THOUGHT: I need to examine the codebase and then look at a specific file. I'll run multiple commands to do this.\n\n    ```bash\n    ls -la\n    ```\n\n    Now I'll read the file:\n\n    ```bash\n    cat file.txt\n    ```\n    &lt;/example_response&gt;\n\n    If you need to run multiple commands, either:\n    1. Combine them in one block using &amp;&amp; or ||\n    ```bash\n    command1 &amp;&amp; command2 || echo \"Error occurred\"\n    ```\n\n    2. Wait for the first command to complete, see its output, then issue the next command in your following response.\n\n    ## Environment Details\n    - You have a full Linux shell environment\n    - Always use non-interactive flags (-y, -f) for commands\n    - Avoid interactive tools like vi, nano, or any that require user input\n    - If a command isn't available, you can install it\n\n    ## Useful Command Examples\n\n    ### Create a new file:\n    ```bash\n    cat &lt;&lt;'EOF' &gt; newfile.py\n    import numpy as np\n    hello = \"world\"\n    print(hello)\n    EOF\n    ```\n\n    ### Edit files with sed:\n    ```bash\n    # Replace all occurrences\n    sed -i 's/old_string/new_string/g' filename.py\n\n    # Replace only first occurrence\n    sed -i 's/old_string/new_string/' filename.py\n\n    # Replace first occurrence on line 1\n    sed -i '1s/old_string/new_string/' filename.py\n\n    # Replace all occurrences in lines 1-10\n    sed -i '1,10s/old_string/new_string/g' filename.py\n    ```\n\n    ### View file content:\n    ```bash\n    # View specific lines with numbers\n    nl -ba filename.py | sed -n '10,20p'\n    ```\n\n    ### Any other command you want to run\n    ```bash\n    anything\n    ```\n\n    ## Submission\n    When you've completed your work (reading, editing, testing), and cannot make further progress\n    issue exactly the following command:\n\n    ```bash\n    echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT &amp;&amp; git add -A &amp;&amp; git diff --cached\n    ```\n\n    This command will submit your work.\n    You cannot continue working (reading, editing, testing) in any way on this task after submitting.\n    &lt;/instructions&gt;\n  action_observation_template: |\n    &lt;returncode&gt;{{output.returncode}}&lt;/returncode&gt;\n    {% if output.output | length &lt; 10000 -%}\n    &lt;output&gt;\n    {{ output.output -}}\n    &lt;/output&gt;\n    {%- else -%}\n    &lt;warning&gt;\n    The output of your last command was too long.\n    Please try a different command that produces less output.\n    If you're looking at a file you can try use head, tail or sed to view a smaller number of lines selectively.\n    If you're using grep or find and it produced too much output, you can use a more selective search pattern.\n    If you really need to see something from the full command's output, you can redirect output to a file and then search in that file.\n    &lt;/warning&gt;\n    {%- set elided_chars = output.output | length - 10000 -%}\n    &lt;output_head&gt;\n    {{ output.output[:5000] }}\n    &lt;/output_head&gt;\n    &lt;elided_chars&gt;\n    {{ elided_chars }} characters elided\n    &lt;/elided_chars&gt;\n    &lt;output_tail&gt;\n    {{ output.output[-5000:] }}\n    &lt;/output_tail&gt;\n    {%- endif -%}\n  format_error_template: |\n    Please always provide EXACTLY ONE action in triple backticks, found {{actions|length}} actions.\n\n    Please format your action in triple backticks as shown in &lt;response_example&gt;.\n\n    &lt;response_example&gt;\n    Here are some thoughts about why you want to perform the action.\n\n    ```bash\n    &lt;action&gt;\n    ```\n    &lt;/response_example&gt;\n\n    If you have completed your assignment, please consult the first message about how to\n    submit your solution (you will not be able to continue working on this task after that).\n  step_limit: 250\n  cost_limit: 3.\n\nenvironment:\n  cwd: \"/testbed\"\n  timeout: 60\n  env:\n    PAGER: cat\n    MANPAGER: cat\n    LESS: -R\n    PIP_PROGRESS_BAR: 'off'\n    TQDM_DISABLE: '1'\n\nmodel:\n  model_name: \"claude-sonnet-4-20250514\"\n  model_kwargs:\n    drop_params: true\n    temperature: 0.0\n</code></pre> <code>swebench.py</code> run script <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>#!/usr/bin/env python3\n\n\"\"\"Run mini-SWE-agent on SWE-bench instances in batch mode.\"\"\"\n# Read this first: https://mini-swe-agent.com/latest/usage/swebench/  (usage docs)\n\nimport concurrent.futures\nimport json\nimport random\nimport re\nimport threading\nimport time\nimport traceback\nfrom pathlib import Path\n\nimport typer\nimport yaml\nfrom datasets import load_dataset\nfrom rich.live import Live\n\nfrom minisweagent.agents.default import DefaultAgent\nfrom minisweagent.config import builtin_config_dir, get_config_path\nfrom minisweagent.environments.docker import DockerEnvironment\nfrom minisweagent.models import get_model\nfrom minisweagent.run.extra.utils.batch_progress import RunBatchProgressManager\nfrom minisweagent.run.utils.save import save_traj\n\n_HELP_TEXT = \"\"\"Run mini-SWE-agent on SWEBench instances.\n\n[not dim]\nMore information about the usage: [bold green]https://mini-swe-agent.com/latest/usage/swebench/[/bold green]\n[/not dim]\n\"\"\"\n\napp = typer.Typer(rich_markup_mode=\"rich\", add_completion=False)\n\nDATASET_MAPPING = {\n    \"full\": \"princeton-nlp/SWE-Bench\",\n    \"verified\": \"princeton-nlp/SWE-Bench_Verified\",\n    \"lite\": \"princeton-nlp/SWE-Bench_Lite\",\n    \"multimodal\": \"princeton-nlp/SWE-Bench_Multimodal\",\n    \"multilingual\": \"swe-bench/SWE-Bench_Multilingual\",\n    \"smith\": \"SWE-bench/SWE-smith\",\n    \"_test\": \"klieret/swe-bench-dummy-test-dataset\",\n}\n\n\n_OUTPUT_FILE_LOCK = threading.Lock()\n\n\nclass ProgressTrackingAgent(DefaultAgent):\n    \"\"\"Simple wrapper around DefaultAgent that provides progress updates.\"\"\"\n\n    def __init__(self, *args, progress_manager: RunBatchProgressManager, instance_id: str = \"\", **kwargs):\n        super().__init__(*args, **kwargs)\n        self.progress_manager: RunBatchProgressManager = progress_manager\n        self.instance_id = instance_id\n\n    def step(self) -&gt; dict:\n        \"\"\"Override step to provide progress updates.\"\"\"\n        self.progress_manager.update_instance_status(\n            self.instance_id, f\"Step {self.model.n_calls + 1:3d} (${self.model.cost:.2f})\"\n        )\n        return super().step()\n\n\ndef get_swebench_docker_image_name(instance: dict) -&gt; str:\n    \"\"\"Get the image name for a SWEBench instance.\"\"\"\n    image_name = instance.get(\"image_name\", None)\n    if image_name is None:\n        # Docker doesn't allow double underscore, so we replace them with a magic token\n        iid = instance[\"instance_id\"]\n        id_docker_compatible = iid.replace(\"__\", \"_1776_\")\n        image_name = f\"swebench/sweb.eval.x86_64.{id_docker_compatible}:latest\".lower()\n    return image_name\n\n\ndef update_preds_file(output_path: Path, instance_id: str, model_name: str, result: str):\n    \"\"\"Update the output JSON file with results from a single instance.\"\"\"\n    with _OUTPUT_FILE_LOCK:\n        output_data = {}\n        if output_path.exists():\n            output_data = json.loads(output_path.read_text())\n        output_data[instance_id] = {\n            \"model_name_or_path\": model_name,\n            \"instance_id\": instance_id,\n            \"model_patch\": result,\n        }\n        output_path.write_text(json.dumps(output_data, indent=2))\n\n\ndef remove_from_preds_file(output_path: Path, instance_id: str):\n    \"\"\"Remove an instance from the predictions file.\"\"\"\n    if not output_path.exists():\n        return\n    with _OUTPUT_FILE_LOCK:\n        output_data = json.loads(output_path.read_text())\n        if instance_id in output_data:\n            del output_data[instance_id]\n            output_path.write_text(json.dumps(output_data, indent=2))\n\n\ndef process_instance(\n    instance: dict,\n    output_dir: Path,\n    model_name: str | None,\n    config_path: str | Path,\n    progress_manager: RunBatchProgressManager,\n) -&gt; None:\n    \"\"\"Process a single SWEBench instance.\"\"\"\n    instance_id = instance[\"instance_id\"]\n    instance_dir = output_dir / instance_id\n    # avoid inconsistent state if something here fails and there's leftover previous files\n    remove_from_preds_file(output_dir / \"preds.json\", instance_id)\n    (instance_dir / f\"{instance_id}.traj.json\").unlink(missing_ok=True)\n\n    image_name = get_swebench_docker_image_name(instance)\n    config = yaml.safe_load(get_config_path(config_path).read_text())\n    model = get_model(model_name, config=config.get(\"model\", {}))\n    task = instance[\"problem_statement\"]\n\n    progress_manager.on_instance_start(instance_id)\n    progress_manager.update_instance_status(instance_id, \"Pulling/starting docker\")\n\n    agent = None\n    extra_info = None\n\n    try:\n        env = DockerEnvironment(**(config.get(\"environment\", {}) | {\"image\": image_name}))\n        agent = ProgressTrackingAgent(\n            model,\n            env,\n            progress_manager=progress_manager,\n            instance_id=instance_id,\n            **config.get(\"agent\", {}),\n        )\n        exit_status, result = agent.run(task)\n    except Exception as e:\n        print(f\"Error processing instance {instance_id}: {e}\\n{traceback.format_exc()}\")\n        exit_status, result = type(e).__name__, str(e)\n        extra_info = {\"traceback\": traceback.format_exc()}\n    finally:\n        save_traj(\n            agent,\n            instance_dir / f\"{instance_id}.traj.json\",\n            exit_status=exit_status,\n            result=result,\n            extra_info=extra_info,\n            instance_id=instance_id,\n        )\n        update_preds_file(output_dir / \"preds.json\", instance_id, model.config.model_name, result)\n        progress_manager.on_instance_end(instance_id, exit_status)\n\n\ndef filter_instances(\n    instances: list[dict], *, filter_spec: str, slice_spec: str = \"\", shuffle: bool = False\n) -&gt; list[dict]:\n    \"\"\"Filter and slice a list of SWEBench instances.\"\"\"\n    if shuffle:\n        instances = sorted(instances.copy(), key=lambda x: x[\"instance_id\"])\n        random.seed(42)\n        random.shuffle(instances)\n    before_filter = len(instances)\n    instances = [instance for instance in instances if re.match(filter_spec, instance[\"instance_id\"])]\n    if (after_filter := len(instances)) != before_filter:\n        print(f\"Instance filter: {before_filter} -&gt; {after_filter} instances\")\n    if slice_spec:\n        values = [int(x) if x else None for x in slice_spec.split(\":\")]\n        instances = instances[slice(*values)]\n        if (after_slice := len(instances)) != before_filter:\n            print(f\"Instance slice: {before_filter} -&gt; {after_slice} instances\")\n    return instances\n\n\n@app.command(help=_HELP_TEXT)\ndef main(\n    subset: str = typer.Option(\"lite\", \"--subset\", help=\"SWEBench subset to use or path to a dataset\"),\n    split: str = typer.Option(\"dev\", \"--split\", help=\"Dataset split\"),\n    slice_spec: str = typer.Option(\"\", \"--slice\", help=\"Slice specification (e.g., '0:5' for first 5 instances)\"),\n    filter_spec: str = typer.Option(\"\", \"--filter\", help=\"Filter instance IDs by regex\"),\n    shuffle: bool = typer.Option(False, \"--shuffle\", help=\"Shuffle instances\"),\n    output: str = typer.Option(\"\", \"-o\", \"--output\", help=\"Output directory\"),\n    workers: int = typer.Option(1, \"-w\", \"--workers\", help=\"Number of worker threads for parallel processing\"),\n    model: str | None = typer.Option(None, \"-m\", \"--model\", help=\"Model to use\"),\n    redo_existing: bool = typer.Option(False, \"--redo-existing\", help=\"Redo existing instances\"),\n    config: Path = typer.Option(\n        builtin_config_dir / \"extra\" / \"swebench.yaml\", \"-c\", \"--config\", help=\"Path to a config file\"\n    ),\n) -&gt; None:\n    dataset_path = DATASET_MAPPING.get(subset, subset)\n    print(f\"Loading dataset {dataset_path}, split {split}...\")\n    instances = list(load_dataset(dataset_path, split=split))\n\n    instances = filter_instances(instances, filter_spec=filter_spec, slice_spec=slice_spec, shuffle=shuffle)\n    output_path = Path(output)\n    if not redo_existing and (output_path / \"preds.json\").exists():\n        existing_instances = list(json.loads((output_path / \"preds.json\").read_text()).keys())\n        print(f\"Skipping {len(existing_instances)} existing instances\")\n        instances = [instance for instance in instances if instance[\"instance_id\"] not in existing_instances]\n\n    output_path.mkdir(parents=True, exist_ok=True)\n    print(f\"Running on {len(instances)} instances...\")\n    print(f\"Results will be saved to {output_path}\")\n\n    progress_manager = RunBatchProgressManager(len(instances), output_path / f\"exit_statuses_{time.time()}.yaml\")\n\n    def process_futures(futures: dict[concurrent.futures.Future, str]):\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                future.result()\n            except concurrent.futures.CancelledError:\n                pass\n            except Exception as e:\n                instance_id = futures[future]\n                print(f\"Error in future for instance {instance_id}: {e}\")\n                traceback.print_exc()\n                progress_manager.on_uncaught_exception(instance_id, e)\n\n    with Live(progress_manager.render_group, refresh_per_second=4):\n        with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as executor:\n            futures = {\n                executor.submit(process_instance, instance, output_path, model, config, progress_manager): instance[\n                    \"instance_id\"\n                ]\n                for instance in instances\n            }\n            try:\n                process_futures(futures)\n            except KeyboardInterrupt:\n                print(\"Cancelling all pending jobs. Press ^C again to exit immediately.\")\n                for future in futures:\n                    if not future.running() and not future.done():\n                        future.cancel()\n                process_futures(futures)\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <code>swebench_single.py</code> run script <ul> <li>Read on GitHub</li> <li>API reference</li> </ul> <pre><code>\"\"\"Run on a single SWE-Bench instance.\"\"\"\n\nfrom pathlib import Path\n\nimport typer\nimport yaml\nfrom datasets import load_dataset\n\nfrom minisweagent.agents.interactive import InteractiveAgent\nfrom minisweagent.config import builtin_config_dir, get_config_path\nfrom minisweagent.environments.docker import DockerEnvironment\nfrom minisweagent.models import get_model\nfrom minisweagent.run.extra.swebench import DATASET_MAPPING, get_swebench_docker_image_name\n\napp = typer.Typer(add_completion=False)\n\n\n@app.command()\ndef main(\n    subset: str = typer.Option(\"lite\", \"--subset\", help=\"SWEBench subset to use or path to a dataset\"),\n    split: str = typer.Option(\"dev\", \"--split\", help=\"Dataset split\"),\n    instance_spec: str = typer.Option(None, \"-i\", \"--instance\", help=\"SWE-Bench instance ID\"),\n    model_name: str | None = typer.Option(None, \"-m\", \"--model\", help=\"Model to use\"),\n    config_path: Path = typer.Option(\n        builtin_config_dir / \"extra\" / \"swebench.yaml\", \"-c\", \"--config\", help=\"Path to a config file\"\n    ),\n) -&gt; None:\n    \"\"\"Run on a single SWE-Bench instance.\"\"\"\n    try:\n        dataset_path = DATASET_MAPPING[subset]\n    except KeyError:\n        dataset_path = subset\n    print(f\"Loading dataset {dataset_path}, split {split}...\")\n    instances = {\n        inst[\"instance_id\"]: inst  # type: ignore\n        for inst in load_dataset(dataset_path, split=split)\n    }\n    if instance_spec.isnumeric():\n        instance_spec = sorted(instances.keys())[int(instance_spec)]\n    instance: dict = instances[instance_spec]  # type: ignore\n\n    _config = yaml.safe_load(get_config_path(config_path).read_text())\n    env = DockerEnvironment(**(_config.get(\"environment\", {}) | {\"image\": get_swebench_docker_image_name(instance)}))\n    agent = InteractiveAgent(\n        get_model(model_name, _config.get(\"model\", {})),\n        env,\n        **(_config.get(\"agent\", {}) | {\"mode\": \"yolo\"}),\n    )\n    agent.run(instance[\"problem_statement\"])\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"}]}